<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Happiness Development</title>
    <link>https://mj-seok.com/</link>
    <description>Recent content on Happiness Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Apr 2020 17:26:44 +0900</lastBuildDate>
    
	<atom:link href="https://mj-seok.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>컴퓨터 일반 요약</title>
      <link>https://mj-seok.com/cs/summary/</link>
      <pubDate>Tue, 07 Apr 2020 17:26:44 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/summary/</guid>
      <description>컴퓨터 일반 요약 1. 마이크로프로세서
2. 클라우드서비스
3. 시스템 종류
4. 디지털 기술
5. 저급 언어와 고급 언어
6. 중앙처리장치 CPU
7. 네트워크의 구조
8. 유비쿼터스 컴퓨팅
9. 교착상태 해결 방안
10. 소프트웨어 종류
11. 데이터베이스 관리 시스템
12. 빅데이터
13. 소프트웨어 개발 프로세스 모델
14. 모바일 기기 운영체제
15. 데이터 용량의 단위
16. IPv4와 TCP
17. 데이터베이스의 뷰(View)
18. 소프트웨어 개발 생명주기
19. 주기억장치와 보조기억장치
20. 개인정보보호법
21. 서비스 거부 공격 (DoS)</description>
    </item>
    
    <item>
      <title>정보자산 식별과 평가분석 방안 - Information Assets</title>
      <link>https://mj-seok.com/cs/information-assets/</link>
      <pubDate>Mon, 06 Apr 2020 11:58:10 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/information-assets/</guid>
      <description>정보자산 식별과 평가분석 방안  서버 : Unix Window? 네트워크 : 스위치 라우터 DB : Oracle MS-SQL Web Page : 회사, 쇼핑몰 더 중요한 자산과 덜 중요한 자산은 어떻게 평가할 수 있을까? 자산들은 누가 관리할까?  피터 드러커  정보자산에는 어떤 것이 있을까? 측정할 수 없으면 관리할 수 없고, 관리할 수 없으면 개선할 수 없다. 피터 드러커(Peter Drucker)  정보자산의 식별 용어 정의  자산 : 조직에서 보유한 가치 있는 모든 것  예) 정보, 소프트웨어, 물리적 자산, 서비스 인력 등   사용자 : 정보처리 설비 및 시스템을 활용하여 자산을 실질적으로 사용하는 사람 혹은 기관 소유자  자산의 소유 권한과 관리에 대한 최종 책임자 자산의 취득, 사용 허가, 처분 또는 폐기 등의 관리 권한 지님   관리자  자산의 소유자로부터 관리 위임을 받은 자 자산의 보관 및 운영 관리 책임을 가짐    자산의 관리 절차  자산의 도입, 변경 폐기되는 자산의 생명주기에 따라 관리 절차에서 주요 활동을 위한 일정 기준과 원칙 정함 자산 관리 프로세스  자산의 관리 정책 수립 자산의 조사 및 식별 자산의 분류 및 등록 자산의 가치 평가 자산의 변경 관리    자산의 관리 정책 수립  보호해야 할 대상을 선별하기 위한 활동 수행  자산 분류 기준 정의 자산 취급 및 관리 기준 수립 지침에 의거하여 자산의 관리 계획 수립 및 수행   자산 관리를 위한 책임자/소유자의 역할 정의 및 권한 부여 일관된 자산분류 기준 수립 및 자산 취급 절차와 방법 정의 자산의 중요도 평가를 위한 활동 수행  평가 요소 도출 평가 원칙과 절차 정의 자산의 가치 등급 부여 기준 수립    자산 조사 및 식별  기업 -&amp;gt; 자사가 보유한 중요 자산 보호 위험을 분석하기 위해 자산목록 작성 필요  적절한 분류기준을 정의/구분/파악하여 자산의 중복이나 누락 방지    자산 식별 대상  정보자산과 관련 있는 모든 것  전자정보 (데이터/DB) 문서 소프트웨어 시설 하드웨어 지원 설비 인력   조직이 IT자산에 의존하여 사업을 진행하고 있는 회사의 경우  서버나 네트워크장비, 애플리케이션 등   설계도면 등 문서화되어 있는 자산이 중요한 제조업이나 엔지니어링 분야의 경우  IT자산 &amp;lt; 출력물이나 PC 등에 저장되어 있는 문서파일 등   지식 기반의 사업을 영위하는 교육기관이나 로펌, 컨설팅펌 등의 경우  전문가들, 인력    자산 분류 기준  유형 자산  시스템 자산 인력 물리적 자산   무형 자산  데이터 소프트웨어   정보 자산 중 중요도 낮은 부분  문서 시설 지원 설비 인력 보안상 미미한 영향, 세부 목록을 작성하지 않는 경우도 있음    상세한 기준  전자정보(데이터/DB) : 전자적 형태로 저장되는 데이터  문서 파일, 데이터 파일, 데이터 베이스 내 데이터   문서 : 종이 매체로 된 정보자산, 업무에 사용/산출되는 문서나 기록물  보고서, 계약서, 매뉴얼, 각종 대장 등   소프트웨어 : 상용 또는 자체 개발된 소프트카피나 하드카피로 보관중인 각종 소프트웨어자산 및 정보자산  네트워크 장비, 통신 회선   시설 : 시스템 설치, 운영 장소, 물리적 공간 및 각종 부대시설  건물, 사무실, 데이터 센터   지원 설비 : 정보 시스템 운영을 지원하기 위한 설비  항온/항습기, UPS, 공조장비 등   인력 : 시스템 운영 및 업무 수행 중인 모든 인력  내부직원, 협력업체   하드웨어  서버 : 대내외 서비스 및 업무를 위해 사용되는 서버 자산  유닉스 서버, 윈도우 서버 등   개인용 컴퓨터 : 임직원이 사용하는 개인 컴퓨터  PC, 노트북, 이동형 단말기 등   네트워크 장비 : 네트워크와 관련된 장비  라우터, 스위치, 허브 등      정리  전자정보  전자적 형태로 저장되는 데이터  데이터베이스, 데이터 파일 등의 전자파일     문서  종이 매체로 된 정보자산 업무에 사용/산출되는 문서나 기록물  규정 및 지침, 각종 대장, 계약서 및 협약서 등     소프트웨어 자산  상용 또는 자체 개발된 소프트카피나 하드카피로 보관 중인 각종 소프트웨어 자산  애플리케이션 소프트웨어, 시스템 소프트웨어, 개발도구 및 유틸리티     하드웨어자산  서버 : 대내외 서비스 및 업무를 위해 사용되는 서버 자산  유닉스 서버, 윈도우 서버 등   개인용 컴퓨터 : 임직원이 사용하는 개인 컴퓨터  PC, 노트북, 이동형 단말기 등   네트워크 장비 : 네트워크와 관련된 장비  라우터, 스위치, 허브 등     시설  시스템 설치, 운영 장소 물리적 공간 및 각종 부대시설  전산실, 사무실, 방재실, 통신 장비실 등     지원설비  전력공급, 환기시설, 방재 시설 등 정보 시스템 운영을 지원하기 위한 설비  항온/항습기, UPS, 공조장비 등     인력  소유자, 사용자, 운영자, 개발자 등 시스템 운영 및 업무 수행 중인 모든 인력  내부직원, 협력업체 등      자산 목록 작성 시의 유의사항  통상적인 조직의 자산을 관리 위한 자산 목록과의 별도의 구분 필요 없음 목록 작성 시 다음의 사항 반드시 명시할 것  자산 유형 식별 번호 자산명 자산의 설명 소유자(책임자/관리자) 중요도 등급(비밀성, 무결성, 가용성)   분석이나 진단 시 활용하기 위한 추가 정보 포함  서버 응용 프로그램 OS 명   자산목록에 반드시 포함되어야 할 항목들을 기록하고, 주기적으로 갱신되어 최신 데이터로 유지되어야만 함  자산 목록표(예)  NO  예) 1, 2, 3 …   자산번호  예) SV-08-001, SV-08-002, SW-08-001 …   구분  예) 서버, 네트워크, 보안장비 …   자산명  예) DB 1서버, L4, 일반스위치 …   용도  예) 데이터베이스, 로드밸런싱, 스위칭 …   OS  예) windows 2003, windows 2000, ubuntu …   응용 프로그램  예) IIS 6.</description>
    </item>
    
    <item>
      <title>위험 관리 - Risk Management</title>
      <link>https://mj-seok.com/cs/risk-management/</link>
      <pubDate>Sat, 04 Apr 2020 12:39:18 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/risk-management/</guid>
      <description>위험관리 개요  위험관리  What? How?   위험 (Risk)  외부의 위협이 내부의 취약성을 이용하여 보유한 각종 자산에 피해를 입힐 수 있는 잠재적인 가능성 (국제보안표준 ISO17799의 위험에 대한 정의) 위협 (Threats)  자산에 손실을 초래할 수 있는, 원치 않는 사건의 잠재적 원인이나 행위자   취약성 (Vulnerability)  위협에 의한 정보 체계의 모든 정보 보안상의 허점 사용자에게 허용된 권한 이상의 동작이나 허용된 범위 이상의 정보 열람을 가능하게 하는 약점 포함 사용자 및 관리자의 부주의나 사회공학 기법에 의한 약점 포함   자산 (Assets)  조직이 보호해야 할 대상 정보, 하드웨어, 소프트웨어, 시설, 인력, 기업 이미지 등      사례 : 모건 스탠리의 위험 (911 테러)    위협 = 비행기 충돌    취약성 = 건물의 내구성    자산 = 건물, 증권 서비스 등   테러라는 위험 발생  위험 관리 (Risk Management)  조직의 자산에 대한 위험을 수용할 수 있는 수준으로 유지하기 위한 과정</description>
    </item>
    
    <item>
      <title>정보보호 동향 Information Security</title>
      <link>https://mj-seok.com/cs/info-sec/</link>
      <pubDate>Thu, 02 Apr 2020 14:50:53 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/info-sec/</guid>
      <description>정보보호 동향   주요 IT 트렌드
  IT 산업의 발전
 개인용 컴퓨터 인터넷 스마트폰    주요 IT 트렌드
 가트너 10대 IT 트렌드 발표 마이크로소프트 4대 메카 IT 트렌드 발표    보안 중요!
  2015년 가트너 10대 IT 트렌드  Merging the Real World and the Virtual World    Computing Everywhere    The Internet of Things    3D Printing     Intelligence Everywhere   Advanced, Pervasive and Invisible Analytics    Context-Rich Systems    Smart Machines     The New IT Reality Emerges   Cloud/Client Computing    Software-Defined Applications and Infrastructure    Web-Scale IT    Risk-Based Security and Self-protection 9      Risk-Based Security and Self-protection  IT 트렌드  클라우드 컴퓨팅  네트워크를 통해 서버 이용 소프트웨어 원격 이용 서비스   빅 데이터  디지털 공간 급속히 팽창하면서 등장 데이터의 실시간 분석으로 시장의 흐름 파악   스마트 디바이스  스마트폰, 태블릿, 스마트 TV 등 기기 폭증 비용, 사회관계, 기업 사업목표, 위험 관리 등 미리 준비   사물 기반 인터넷  차기 IT 산업의 주요 성장 동인 사물지능통신(Intelligence Machine-to-Machine communication)   스마트 워크  스마트 워크에 대한 수요 점차 증가 사무공간 재설계로 업무 만족도 향상, 업무 만족도, 비용 절감 효과 획득    2013년 마이크로소프트 4대 메가 트렌드  기술  Device + Service   전략  Platform + Ecosystem   산업  App = Web    4대 분야  모빌리티 (Mobility)  스마트폰의 2천만 시대 진입으로 인해 국내 모바일 시장이 크게 진화 공급과 소비의 주체가 기업에서 개인으로 빠르게 재편됨에 따라 이에 대한 서비스 개발과 시장 선점 필요   소셜 컴퓨팅 (Social Computing)  현재까지 명확한 수입모델이 없었던 소셜 컴퓨팅 분야의 많은 비즈니스 모델	창출 기대   클라우드 (Cloud)  애플의 아이클라우드로 인해 퍼스널 클라우드 전쟁이 더욱 치열 클라우드 컴퓨팅을 통해 차별화 역량을 확보한 분야를 중심으로 새로운 비즈	니스 모델을 찾는 것이 중요   빅 데이터 (Big Data)  스마트기기, 소셜 미디어의 등장으로 데이터가 폭증하는 빅 데이터의 시대 도래 빅 데이터를 경제적 자산으로 정책에 활용하는 실질적인 빅 데이터 전략이 필요    주요 요소  클라우드 컴퓨팅 디지털 콘텐츠 확산 소셜 서비스 플랫폼 자연스런 인터페이스 HTML5 빅 데이터 스마트 디바이스 스마트워크  정보보호와 피해 사례 개인 정보의 활용 사례  공공기관  온라인 정보제공 DB 연계를 통한 행정효율화 등   학원, 교습소  온라인 수강신청, 수강자 관리 인터넷 오프라인 연계 학습 환경   영화관  인터넷, 모바일 예매 무인발권시스템   여행업  전자항공권 발권 실시간 온라인 예약   결혼중개업  온, 오프라인을 통해 맞춤형 결혼 중개   정유업  주유 고객 멤버쉽 주유 마일리지 제공   주택관리업  홈 네트워킹 관리    개인 정보의 노출/유출  은행 전자 게임사 오픈마켓 쇼핑몰 정유사 통신사 등 44명 ~ 2,000만명 유출  무선 네트워크 보안 위협  보안 설정이 취약한 공유기 통한 모바일 악성앱 유포 문제점  DNS 변조된 유무선 공유기의 와이파이를 통해 인터넷 접속 시 발생 악성앱의 설치로 개인정보 유출   해결 방법  공유기 펌웨어를 최신 버전으로 업데이트 유지 기본/보조 DNS 서버 IP 주소 자동 설정 관리자 페이지 로그인 계정 및 암호 설정 원격 관리 포트 사용 해제   피해 사례  45만 7천명의 카드 이용자 정보가 누출 망원경 모양의 안테나를 이용해 무선 링크 접근 무선링크는 WEP를 이용하여 암호화    피싱 사이트  개인정보 Private Data 와 낚시 Fishing 의 합성어로 개인정보를 낚는다는 의미 피해사례  금융기관 또는 공공기관을 가장해 전화나 이메일로 인터넷 사이트에서 보안	카드 일련번호와 코드번호 일부 또는 전체를 입력하도록 요구해 금융 정	보를 몰래 빼가는 수법 일반 PC는 물론이고 모바일 기기에서의 개인 정보 유출 위협 증가    모바일 보안 위협  PC 보안 위협 + 모바일 요인 = 모바일 보안 위협 스마트폰 이용자 10대 안전수칙   의심스러운 애플리케이션 다운로드하지 않기    신뢰할 수 없는 사이트 방문하지 않기    발신인이 불명확하거나 의심스러운 메시지 및 메일 삭제하기    비밀번호 설정 기능을 이용하고 정기적으로 비밀번호 변경하기    블루투스 기능 등 무선 인터페이스는 사용 시에만 켜놓기    이상 증상이 지속될 경우 악성코드 감염 여부 확인하기    다운로드한 파일은 바이러스 유무를 검사한 후 사용하기    PC에도 백신 프로그램을 설치하고 정기적으로 바이러스 검사하기    스마트폰 플랫폼의 구조를 임의로 변경하지 않기    운영체제 및 백신프로그램을 항상 최신 버전으로 업데이트 하기    APT 공격  Advanced Persistent Threat 지능형 지속적 위협으로 불리는 공격의 형태 정해진 목표(금전, 이념, 정치 등)를 달성하기 위해 고도의 기법을 이용하여 지속적	으로 공격을 감행하는 공격 프로세스 이전에 화제가 되었던 농협, 네이트 해킹 등이 이에 해당  APT 공격의 단계  침투  공격자가 취약한 시스템이나 직원들을 악성코드로 감염시켜 네트워크 내부	로 침투   탐색  침투한 내부 시스템 및 인프라 구조에 대한 정보를 수집한 후 다음 단계를 계	획   수집  보호되지 않은 시스템상의 데이터 수집, 은밀하게 데이터 수집 또는 시스템 운영 방해를 위한 악성코드 설치   유출  분석 및 추가 공격/사기를 위해 데이터를 공격자의 본거지 전송    예제    해커는 Document exploit이 첨부된 Email을 준비    Email은 Target 사용자에게 전송, Document Open되면 Backdoor 설치    내부 네트워크 취약점 Scanning(ARP/Port)    알려진 Exploit 으로 추가 PC 공격    Backdoor 감염 &amp;amp; 정보 유출    사이버 위협의 진화  단순 악성코드, 단순 시비, 폭행  개인 파일 손상 실력 과시   게임 아이템 현금화, 단순 절도 현금화  금전적 이득 개인의 물질적 피해   개인정보탈취, 인터넷뱅킹, 금융사기 등  금전적 이득 개인정보 유출   국가기관 산업 테러 위협, 산업시설 공격, DDoS 공격  정치적 의도 기업 신뢰도 타격    스마트기기의 보안  기존 PC의 위협  보안 통제, 암호화, 방화벽, 백신 등 여러 가지 보안 기술을 이용하여 외부의 위협으로부터 대응 가능   안드로이드 OS의 위협  오픈 소스의 플랫폼으로 개방성 중시 1인 1디바이스를 사용 애플리케이션을 손쉽게 만들 수 있음 앱을 쉽게 배포하여 설치 가능   일반적인 PC와는 다르게 여러 보안 기술을 적용하기 어려워 쉽게 위험 노출  클라우드 컴퓨팅의 보안  해외 많은 보고서에서 가상화 기술에 대한 보안 헛점 지적 Management  관리 취약점 안전한 데이터 관리 책임 추구성 확보   Applications / Operating System  기존 IT 인프라의 위협과 동일한 위협 존재   Virtual Machine  서비스 사용 임의 확장 서비스 영역 동적 재위치 (Private Zone -&amp;gt; Shared) 가상 머신 도난   VMM or Hypervisor  자원 임의 공유 단일 실패 위험(DoS)   Hardware  루트킷에 의한 하드웨어 공격 가상 네트워크 기반 공격    소셜 네트워크의 보안  악성코드에 의한 위협  소셜 네트워크 사이트를 촉매제로 이용하여 과거보다 더 많은 사람들에게 피	해를 입힘   피싱(Phishing) 위협  소셜 네트워크에서는 과거보다 더 쉽게 사람들을 피싱 위협에 노출시킬 수 있음   Evil Twin Attack (SNS 신원 복제)  도플갱어와 같이 다른 사람이 소셜 네트워크 상에서 어떤 특정한 사람과 동	일한 존재를 만드는 공격 기법 직접적인 피해를 주지는 않지만, 이로 인해 명예훼손, 금전적인 손실, 사이버 폭력과 같은 일이 발생할 수 있음   신원 도용 (Identity Theft)  소셜 네트워크의 발달과 함께 사람들은 과거보다 더 많이 자신에 대한 정보	를 소셜 네트워크 사이트에 흘려버림 공격자는 이러한 정보를 통해 예전보다 손쉽게 다른 사람으로 도용 가능   사이버불링 (Cyberbullying)  10대 이하의 어린 학생들을 대상으로 소셜 네트워크를 통해 음해나 욕설을 하는 공격    보안 위협 분석  SYN Flooding  TCP/IP 프로토콜은 서버와 클라이언트 연결을 위해 3-way-Handshake 클라이언트서버 : SYN, 서버클라이언트 : SYN-ACK.</description>
    </item>
    
    <item>
      <title>소프트웨어 안전 - Software Safety</title>
      <link>https://mj-seok.com/cs/software-safety/</link>
      <pubDate>Wed, 01 Apr 2020 21:42:04 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/software-safety/</guid>
      <description>소프트웨어 안전  전자제어장치 ECU에 내장된 소프트웨어 결함 KTX 사고 - 철도 제어 소프트웨어 F4 팬텀 - 5% 기능 소프트웨어 제어 F22 레프터 - 90% 이상의 기능이 소프트웨어에 의해서 제어 원자력의 모든 제어 시설이 소프트웨어에 의해서 자동적으로 제어  정의  아래의 것들을 보장하는 특징과 절차  Features and Procedure which ensure that   소프트웨어가 정상적, 비정상적인 환경 아래에서 예상대로 작동하는 것  A product performs predictably under normal and abnormal conditions   미리 계획하지 않은 사건 발생의 가능성 최소화 및 그 결과 통제와 방지  The likelihood of an unplanned event occurring is minimized and its consequences controlled and contained   고의든 무의지든 돌발적인 피해 혹은 사망 예방  Preventing accidental injury or death, whether intentional or unintentional    기능적인 안전 Functional Safety  위험 Risk  개연성의 조합 및 예기치 않은 사건의 영향 Combination of the probability and impact of an unexpected event   안전 Safety  물리적 침해의 받아들일 수 없는 위험에서의 자유 혹은 사람들의 건강에 대한 피해 Freedom from unacceptable risk of physical injury or of damage to the health of people   기능적인 안전 Functional Safety  시스템에 의존하는 종합적인 안전 부분 The part of the overall safety that depends on a system 입력에 대응하여 정확하게 운영되는 장비 Equipment operating correctly in response to its inputs 위험해질 가능성이 있는 환경 발견 The detection of a potentially dangerous condition resulting in the activation of a protective    IEC 61508  IEC 61508  전기, 전자 및 Programmable 전자 시스템의 기능 안전   적용과 관계없이 전기, 전자 및 Programmable 전자 시스템의 기능 안전을 다루는 일반 안전 표준으로 간주  임베디드 시스템, 모든 전자 장비에 들어가 있는 소프트웨어 또는 하드웨어   제어 시스템의 기능 안전에 대한 주요 표준 안전에 있어 안전 시스템의 요구사항을 규정하는 데 사용  제품을 만드는 데 개발 라이프사이클 동안 사용됨   기능적인 안전에 관련된 인증 표준  산업별 안전 표준 Safety Standards  AUTOMOTIVE : ISO 26262 RAILWAY APPLICATION : EN 50128, EN 50123, EN 50129, IEC 62278, IEC 62279 MACHINERY : ISO 13849, IEC 62061 : Safety of machinery PROCESS INDUSTRY : IEC 61511 : Functional safety - Safety  Instrumented system for the process industry   NUCLEAR : IEC 61513, IEC 60880 MEDICAL  IEC 62304 : Medical device software IEC 60601 : Medical Electrical Equipment   OTHERS (AVIATION)  DO178B, 178C; 감항 인증 표준 airworthiness certification standard    IEC 61508 Framework  Part 0 : Functional Safety and IEC 61508 Part 1 : General Requirements Part 2 : Requirements for Electrical / Electronic / Programmable Electronic Safety-related Systems Part 3 : Software Requirements Part 4 : Definitions and Abbreviations Part 5 : Examples of Methods for the Determination of Safety Integrity Levels(SILs) Part 6 : Guidelines on the Application of IEC 61508-2 and IEC 61508-3 Part 7 : Overview of Measures and Techniques  Overall Safety Lifecycle for E/E/PE systems  Concept Overall Scope Definition Hazard &amp;amp; Risk Analysis  발생 확률에 대한 위험요소를 분석   Overall Safety Requirements Safety Requirements Allocation  하드웨어적 또는 소프트웨어적으로 구성   E/E/PES System Safety Requirements Specification  생명 주기  스펙에 따라 디자인 후 개선 및 향상 안전 요구사항 Testing Validation 제품 출시  소프트웨어 안전 생명 주기  소프트웨어 관련 안전 요구사항을 어떻게 스펙하는지 스펙에 따라 어떻게 개발하는지 개발 후 안전 관점에서 어떻게 테스팅 하는지 테스팅 후 통합되어 제품으로 나가는 전체적이고 일반적인 과정  SILs Safety Integrity Levels  주어진 모든 조건하에 있는 안전관련 시스템이 주어진 시간 내에 요구되는</description>
    </item>
    
    <item>
      <title>데이터에 대한 결정</title>
      <link>https://mj-seok.com/cs/ml/</link>
      <pubDate>Tue, 31 Mar 2020 21:52:51 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/ml/</guid>
      <description>데이터에 대한 결정  기계 학습의 본질  데이터로부터 배울 수 있는 능력, 예측 및 결정을 내릴 수 있는 알고리즘   인공 지능을 목표하는 단계  분류  결정 과정 : 분류 classification 알고리즘 : 분류자 Feature : 특징화 훈련 데이터(Training Data)와 분류된 데이터(Labeled Data)  선점도 데이터 시각화  알고리즘의 목적 : 최적의 구분/분류를 찾는 것 분할 추가 의사 결정 경계 : Decision Boundary 오차 행렬 : Confusion Matrix  사용되는 알고리즘  결정 트리 Decision Tree 서포트 벡터 머신 (Support Vector Machines)  머신 러닝 문제  HyperLane 통계학 Statistics 기반  인공 신경망 Artificial Neural Networks  입력 레이어(Input Layer) - 숨겨진 레이어(Hidden Layer) - 출력 레이어(Output Layer)</description>
    </item>
    
    <item>
      <title>사무행정과 한글</title>
      <link>https://mj-seok.com/tech/hangul/</link>
      <pubDate>Mon, 30 Mar 2020 21:27:15 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/hangul/</guid>
      <description>행정이란?  행정 : 광의와 협의 정부, 기업이나 모든 조직은 목표를 달성하기 위해 관리를 합니다. 광의 : Administration 관리 협의 : Public NGO 공익  협의의 행정  행정의 정의가 구체화 됩니다. 기업이 아니라 정부가 하는 활동, 이익이 아니라 공익을 추구하는 활동 행정은 경영과 다릅니다. 공사 행정 이원론, 정치 행정 일원론  거버넌스(Governance)  거버넌스(Governance) : Govern(통치하다)에서 파생, 협치라는 의미 Government : 통치 정부 - 시장 - 시민사회 신뢰, 네트워크, 투명성 중요하게 여겨지는 가치  사무 행정 업무 수행 계획  하는 일들에 대해 계획 어떤 역할을 수행할 수 있을지 예) 민원 응대를 어떻게 구체적으로 대응할 것인지 추진하고 있는 방향성과 사업 계획 단기간의 포부 장기간의 포부  한글 문서 - 문단 나누기와 줄 바꿈  문단 나누기 : Enter 엔터 줄 바꿈 : Shift 쉬프트 + Enter 엔터  여러 기능  눈금자 10px - 2.</description>
    </item>
    
    <item>
      <title>품질 속성 - Quality Attributes</title>
      <link>https://mj-seok.com/cs/quality-model/</link>
      <pubDate>Thu, 26 Mar 2020 22:28:44 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/quality-model/</guid>
      <description>품질 속성 - Quality Attributes 이전 소프트웨어 개발자들의 생각  소프트웨어 가장 중요한 요소 - 구조 ? 기능적 요구 만족  결합된 수요 Combined Demand  성능 Performance 유효성 Availability 수정 가능성 Modifiability 신뢰성 Reliability 구조가 아닌 다른 의미에서 만족할 수 있는 속성 품질 속성  품질 속성  비기능 요구사항 Non-functional Requirement 구조에 따라 비기능 요구사항들이 달라지는 경우  Sort Program 알고리즘을 사용할 때 알고리즘에 따라서 속도, Attribute이 달라지는 경우.</description>
    </item>
    
    <item>
      <title>소프트웨어 품질 - Software Quality</title>
      <link>https://mj-seok.com/cs/software-quality/</link>
      <pubDate>Tue, 24 Mar 2020 11:33:44 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/software-quality/</guid>
      <description>소프트웨어 품질 - Software Quality  품질 Quality 노력(수고) Effort 일정 Schedule   소프트웨어 품질 정의 품질 특성 품질 표준 품질 안전성 인증  소프트웨어 품질 정의  명백하게 또는 내포적으로 요구사항 및 기대사항을 부합한 정도  품질의 두 가지 형태  설계 품질(Quality of Design)  요구사항 포함(Encompasses requirements), 사양(specifications), 시스템 디자인(design of the system)   부합 품질 (Quality of Conformance)  An issue focused primarily on implementation 사양이나 설계가 얼만큼 부합하는지 측정     사용자 만족 User Satisfaction</description>
    </item>
    
    <item>
      <title>텍스트 마이닝 - Text Mining</title>
      <link>https://mj-seok.com/cs/text-mining/</link>
      <pubDate>Sun, 22 Mar 2020 11:32:46 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/text-mining/</guid>
      <description>텍스트 마이닝 - Text Mining 1. 필요 요구 사항
2. 텍스트 마이닝 소개
3. 텍스트 마이닝의 이해
4. 텍스트 마이닝 기법 소개
5. 텍스트 표현의 단위
6. Character 단위 분석
7. 단어 단위 텍스트 분석
8. Zipf’s 법칙
9. 구 단위 텍스트 분석
1. 필요 요구 사항  자바는 프로그래밍 언어  자바로 쓰인 고급 프로그래밍 언어 자바와 기계 코드를 돌리기 위해 자바 컴파일러와 가상 머신을 사용함   Java JDK Eclipse yTextMiner  2.</description>
    </item>
    
    <item>
      <title>애자일 방법론 - Agile Method</title>
      <link>https://mj-seok.com/cs/agile/</link>
      <pubDate>Fri, 20 Mar 2020 08:58:55 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/agile/</guid>
      <description>애자일 방법론 - Agile Method 1. eXtreme Programming(XP)
2. Scrum
프로세스 선택 시 고려해야 될 특징(Characteristic)
1. eXtreme Programming(XP)  소규모 ~ 중간규모 팀이 빠른 요구사항 변화에 반응하여 개발하는 경량 소프트웨어 개발 방법론 여러 practice를 적용하게 간단하게 개발할 수 있음.  12 Practices  The Planning Game : 개발자와 고객 간 role game, 어떻게 이 시스템을 사용할 것인가? Small Releases : 짧은 개발 Lifecycle 동안 어떻게 scope를 정하여 소프트웨어를 인계할 것인가?</description>
    </item>
    
    <item>
      <title>데이터 통신</title>
      <link>https://mj-seok.com/cs/network/</link>
      <pubDate>Thu, 19 Mar 2020 14:29:33 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/network/</guid>
      <description>데이터 통신 1. 정의
2. 정보통신의 발전
3. 데이터 통신 시스템의 구성 요소
4. 데이터 전송기술
1. 정의  컴퓨터에 의한 정보처리기술과 데이터 전송 기술이 통합된 형태  데이터 통신 = 데이터 전송 + 데이터 처리    2. 정보통신의 발전  Morse(1844) : 전신, 전기통신의 시초 Bell(1876) : 전화 발명, 음성 통신 텔레타이프회선에 의한 데이터 통신(1940) ENIAC 개발(1946) EDSAC 개발(1950) UNIVAC-1 개발(1951) SAGE(1958) : Semi-Automatic Ground Environment  세계 최초의 데이터 통신, 반자동 방공 시스템(군사용)   SABRE(1961) : Semi-Automatic Business Research Environment  세계 최초의 상업용 데이터 통신 아메리칸 항공사의 좌석예약 및 회계 업무 시스템   CTSS(1963)  Compatible Time Sharing System 최초의 실험용 시분할 시스템   MULTICS  Multiplex of Information and Computing Service CTSS를 발전시킨 시스템   ARPA 네트워크(1968)  Advanced Research Project Agency 최초의 패킷 교환(Packet Switching) 시스템 인터넷의 효시   ALOHA 시스템(1968)  Addictive Links Online Hawaii Area 최초의 무선 패킷 교환망   SNA(1974)  System Network Architecture IBM이 발표한 컴퓨터 시스템을 이용한 통신망을 구축하는 통신망 구조   TELNET, TYNET(1975)  상업용 패킷 교환 데이터 통신 시스템   GE Mark -1  상업용 시분할 시스템    3.</description>
    </item>
    
    <item>
      <title>유닉스 Unix</title>
      <link>https://mj-seok.com/cs/unix/</link>
      <pubDate>Thu, 19 Mar 2020 11:23:27 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/unix/</guid>
      <description>유닉스 Unix 1. 유닉스의 특징
2. 유닉스의 구성요소
3. 유닉스의 파일 시스템
4. 디스크 블록 구조
5. 유닉스 명령어
1. 유닉스의 특징  대화형 시스템 다중사용자 시스템 다중 작업용 시스템 높은 이식성과 확장성 제공 계층적 트리 파일 시스템  2. 유닉스의 구성요소  커널 : 프로세스 관리, 메모리 관리, 파일 시스템 관리, 장치 관리 등 컴퓨터의 모든 자원을 초기화하고 제어하는 기능을 수행 함. 셸 : 사용자와 커널 사이의 중간자 역할을 담당하는 프로그램으로 사용자가 입력한 명령을 해석하여 커널에 넘겨줌.</description>
    </item>
    
    <item>
      <title>디스크 관리</title>
      <link>https://mj-seok.com/cs/disk/</link>
      <pubDate>Thu, 19 Mar 2020 11:12:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/disk/</guid>
      <description>1. 디스크 할당 방법
1. 디스크 할당 방법  디스크의 빈 공간 관리  비트 벡터  빈 공간 리스트는 비트맵(bit map) 또는 비트벡터(bit vector)로서 구현 블록이 비어있으면 0, 블록이 할당되어 있으면 1   연결 리스트  모든 빈 디스크 블록들을 함꼐 연결 첫 번째 빈 블록 안에 다음의 빈 디스크 블록의 포인터를 갖고 있음.     연속 할당(Contiguous Allocation)  파일들이 디스크의 연속적인 주소들의 집합에 할당되는 방식 파일에 접근할 때 필요한 디스크 탐색의 횟수는 최소화될 수 있음 새로운 파일을 위해 빈 공간을 찾는 것은 어려움 전체 디스크 공간이 요구량을 만족하여도, 연속된 공간이 아니면 외부 단편화 발생 주기적인 압축이 필요   연결 할당 (Linked Allocation)  각 파일들이 디스크 블록들의 리스트에 연결 디스크 블록들은 디스크 전체에 분산 디렉터리는 파일의 첫 번째와 마지막 블록의 포인터를 가짐 외부 단편화 발생하지 않음 직접 액세스 기능을 지원할 수 없음 포인터를 위한 기억공간이 필요함   인덱스 할당  연결할당은 연속할당의 외부 단편화를 해결했으나 직접 액세스를 지원할 수 없고 블록들의 포인터가 디스크 전체에 분산되어 있음 인덱스 할당은 모든 포인터들을 하나의 장소, 즉 인덱스 블록으로 관리하여 직접 액세스를 지원함    </description>
    </item>
    
    <item>
      <title>ECMAScript 6 - Arrow 함수</title>
      <link>https://mj-seok.com/javascript/es6-arrow/</link>
      <pubDate>Fri, 13 Mar 2020 15:29:12 +0900</pubDate>
      
      <guid>https://mj-seok.com/javascript/es6-arrow/</guid>
      <description>ECMAScript 6 - Arrow 함수  arrow의 사전적 의미는 &amp;ldquo;화살, 화살표(=&amp;gt;)&amp;ldquo;이며 의미보다 표기가 더 어울립니다. 영어 발음보다 화살표가 더 직관적이므로 이 책에서는 &amp;ldquo;화살표 함수&amp;quot;로 표기합니다.   (param) =&amp;gt; { 코드 };
param =&amp;gt; { 코드 };
() =&amp;gt; { 코드 };
(param1, param2, , , , paramN) =&amp;gt; { 코드 };
param =&amp;gt; ( { key: value });
(param1, param2, &amp;hellip;rest) =&amp;gt; { 코드 };
(param1, param2 = 123, , , paramN) =&amp;gt; { 코드 };</description>
    </item>
    
    <item>
      <title>ECMAScript 6 - var, let, const</title>
      <link>https://mj-seok.com/javascript/es6/</link>
      <pubDate>Fri, 13 Mar 2020 12:40:07 +0900</pubDate>
      
      <guid>https://mj-seok.com/javascript/es6/</guid>
      <description>ECMAScript 6 - var, let, const 1. var 키워드
2. let 키워드
3. 블록 스코프
4. let과 this 키워드
5. function
6. try-catch
7. switch-case
8. 호이스팅
9. for()
10. const
 자바스크립트 코드 실행되려면  코드 컴파일 실행할 자바스크립트 엔진이 필요 ECMA 262 스펙   ES6  객체지향 언어의 장점을 적극적으로 도입 효율적인 메모리 사용에 중점   빌트인 오브젝트  엔진이 사전에 오브젝트로 생성한 것 사전 처리를 하지 않고 바로 사용할 수 있는 것 Function, Object, Array, Number, String 등의 오브젝트   object  첫 문자가 영문 소문자이고 빌트인 오브젝트로 생성한 오브젝트를 의미 첫 문자가 대문자인 Object는 {key: value} 형태를 의미   인스턴스  new 연산자와 생성자 함수로 인스턴스를 생성합니다.</description>
    </item>
    
    <item>
      <title>압축 알고리즘 - 제 3단계 Huffman Tree</title>
      <link>https://mj-seok.com/algorithm/compression3/</link>
      <pubDate>Thu, 12 Mar 2020 18:12:12 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/compression3/</guid>
      <description>압축 알고리즘 - 제 2단계 Huffman Tree  인코딩 데이터 파일을 압축하기 위해서는 데이터 파일을 다시 시작부터 읽으면서 run을 하나씩 인식한 후 해당 run에 부여된 codeword를 검색합니다. Huffman트리에는 모든 run들이 리프노드에 위치하므로 검색하기 불편합니다. 검색하기 편리한 구조를 만들어야 합니다.  Array of Linked Lists  크기가 256인 배열 chars[&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;lsquo;C&amp;rsquo;, &amp;lsquo;D&amp;rsquo;, &amp;hellip;] symbol codeword freq runLen codewordLen next(right) 각 run의 right 필드를 다음 노드를 가리키는 링크필드로 사용합니다. symbol이 동일한 run들을 하나의 연결리스트로 저장합니다.</description>
    </item>
    
    <item>
      <title>입출력 처리 방식 - I/O Process Method</title>
      <link>https://mj-seok.com/cs/process/</link>
      <pubDate>Thu, 12 Mar 2020 13:07:06 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/process/</guid>
      <description>입출력 처리 방식 - I/O Process Method  폴링 방식 인터럽트 방식  1. 폴링 방식  데이터 링크 확립 방식의 하나입니다. 분기 방식을 사용하고 있는 시스템에서 각 단말에서의 송신을 제어하기 위해서 사용되고 있습니다. 이것을 폴링/셀렉팅 방식 또는 폴링/드레싱 방식이라고 합니다.  2. 인터럽트 방식  프로세서(CPU, 중앙처리장치)의 즉각적인 처리를 필요로 하는 이벤트를 알리기 위해 발생하는 주변 하드웨어나 소프트웨어로 부터의 요청을 말합니다. 인터럽트가 발생하면 그 순간 운영체계 내의 제어프로그램에 있는 인터럽트 루틴이 작동하며 응급사태를 해결하고 인터럽트가 생기기 이전의 상태로 복귀시킵니다.</description>
    </item>
    
    <item>
      <title>컴퓨터 보안 - Computer Security</title>
      <link>https://mj-seok.com/cs/security/</link>
      <pubDate>Thu, 12 Mar 2020 12:59:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/security/</guid>
      <description>컴퓨터 보안 - Computer Security  가상사설망(VPN) 패스워드 관리 안드로이드 보안  1. 가상사설망(VPN)  인터넷 같은 공중망을 사용하여 사설망을 구축하게 해주는 기술 또는 통신망 인터넷이라는 공중망을 기본으로 하기 때문에 적절한 통신속도 및 대역폭에 대해 보장이 필요합니다. 확실한 정보보호를 위한 암호화 기술과 전자인증 기술이 핵심 구현 기술입니다.   데이터 암호화, 접근제어, 터널링
 2. 패스워드 관리  주 컴퓨터의 운영체제(OS), 데이터베이스관리시스템(DBMS)에 의하여 관리됩니다. 일반적으로 7문자 이상의 영문자와 숫자의 조합으로 구성되어 지정됩니다.</description>
    </item>
    
    <item>
      <title>컴퓨터 포렌식 (Computer Forensics)</title>
      <link>https://mj-seok.com/cs/forensics/</link>
      <pubDate>Thu, 12 Mar 2020 12:53:49 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/forensics/</guid>
      <description>컴퓨터 포렌식 (Computer Forensics)  컴퓨터 법의학 또는 디지털 포렌식 -전자적 증거물 등을 사법기관에 제출하기 위해 데이터를 수집, 분석, 보고서를 작성하는 일련의 작업  포렌식의 유형  네트워크 포렌식이란  네트워크에서 디지털 증거를 수집하고 분석하여 법정에 제출하는 일련의 과정 인터넷을 통하여 발생하는 범죄에 대한 디지털 증거를 수집하고 분석하는 것   이메일 포렌식  이메일 데이터로부터 송수신자, 보낸 및 받은 시간, 내용 등의 증거 획득 및 분석   웹 포렌식  웹 브라우저를 통한 쿠키, 히스토리, 임시파일, 설정 정보 등을 통해 사용 흔적 분석   안티 포렌식  데이터의 완전삭제, 암호화, 스테가노그래피 등을 의미합니다.</description>
    </item>
    
    <item>
      <title>웹사이트 및 브라우저 주요 공격 유형</title>
      <link>https://mj-seok.com/cs/hacking-series/</link>
      <pubDate>Thu, 12 Mar 2020 12:50:44 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/hacking-series/</guid>
      <description>웹사이트 및 브라우저 주요 공격 유형  크로스사이트 요청 위조 크로스사이트 스크립팅 SQL 인젝션 비트플리핑 공격  크로스사이트 요청 위조  새로운 공격은 아니지만, 간단하고 매우 위협적인 공격입니다. 로그인한 피해자의 브라우저가 취약한 웹 애플리케이션에 요청을 보내도록 하여 피해자 대신 선택된 작동을 수행하도록 합니다. 특별한 공격 포인트가 없습니다. HTTP 트래픽 변조하지 않고, 문자나 인코딩 기법을 사용하지 않습니다. 브라우저에서 사용자 몰래 요청이 일어나게 강제하는 공격입니다.  </description>
    </item>
    
    <item>
      <title>압축 알고리즘 - 제 2단계 Huffman Tree</title>
      <link>https://mj-seok.com/algorithm/compression2/</link>
      <pubDate>Tue, 10 Mar 2020 13:27:05 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/compression2/</guid>
      <description>Huffman coding  Huffman coding 알고리즘은 트리들의 집합을 유지하면서 매 단계에서 가장 frequency가 작은 두 트리를 찾아서 두 트리를 하나로 합칩니다. 이런 연산에 가장 적합한 자료구조는 최소 힙(minimum heap)입니다. 즉, 힙에 저장된 각각의 원소들은 하나의 트리입니다. (노드가 아니라요)  최소 힙  크기가 5인 힙, 5개의 트리가 저장되어 있습니다. 5개의 single node tree 각 트리는 오직 하나의 노드로 구성됩니다.  class Run 수정하기 class Run implements Comparable&amp;lt;Run&amp;gt; { public byte symbol; public int runen; public int freq; } /* 트리의 노드로 사용하기 위해서 왼쪽 자식과 오른쪽 자식 노드 필드를 추가합니다.</description>
    </item>
    
    <item>
      <title>압축 알고리즘 - Compression</title>
      <link>https://mj-seok.com/algorithm/compression/</link>
      <pubDate>Wed, 04 Mar 2020 10:28:37 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/compression/</guid>
      <description>압축 알고리즘 - Compression  Huffman Coding  Huffman Coding  가령 6개의 문자 a, b, c, d, e, f 로 이루어진 파일이 있다고 합니다. 문자의 총 개수는 100,000개이고 각 문자의 등장 횟수는 다음과 같습니다. 고정길이 코드를 사용하면 각각의 문자를 표현하기 위해서 3비트가 필요하며, 따라서 파일의 길이는 300,000비트가 됩니다. 테이블의 가변길이 코드를 사용하면 224,000바이트가 됩니다.  테이블    a b c d e f   Frequency(천단위) 45 13 12 16 9 5 Fixed-length code 000 110 010 011 100 101 Variable-length 0 101 100 111 1101 1100  Prefix code  어떤 codeword도 다른 codeword의 prefix가 되지 않는 코드 여기서 codeword란 하나의 문자에 부여된 이진코드를 말합니다.</description>
    </item>
    
    <item>
      <title>최단경로 알고리즘 - Shortest Path Problem 3</title>
      <link>https://mj-seok.com/algorithm/spp3/</link>
      <pubDate>Tue, 03 Mar 2020 11:04:33 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/spp3/</guid>
      <description>최단경로 알고리즘 - Shortest Path Problem 3  all to all 알고리즘  Floyd-Warshall Algorithm  가중치 방향 그래프 G=(V, E), V={1, 2, &amp;hellip;, n} 모든 노드 쌍들간의 최단경로의 길이를 구함 d^k[i, j]  중간에 노드집합 {1, 2, &amp;hellip;, k}에 속한 노드들만 거쳐서 노드 i에서 j까지 가는 최단경로의 길이   d^0[i, j] = {if (i, j) ∈ E =&amp;gt; W(i, j), Infinity} d^k[i, j] = min{d^(k-1)[i, j], d^(k-1)[i, k] + d^(k-1)[k, j]}  중간정점들이 모두 {1, 2, &amp;hellip;, k-1}에 속함 중간정점들이 모두 {1, 2, &amp;hellip;, k}에 속함   d^n[i, j] = S(i, j) 중간에 노드집합 {1, 2, &amp;hellip;, k}에 속한 노드들만 거쳐서 노드 i에서 j까지 가는 최단경로는 두가지 경우가 있음: 노드 k를 지나는 경우와 지나지 않는 경우  Floyd-Warshall Algorithm  d^k[i, j] = min{d^(k-1)[i, j], d^(k-1)[i, k] + d^(k-1)[k, j]}  FloydWarshall(G) { for i &amp;lt;- 1 to n for j &amp;lt;- 1 to n d^0[i, j] &amp;lt;- W(i, j); for k &amp;lt;- 1 to n // 중간정점 집합 {1, 2, .</description>
    </item>
    
    <item>
      <title>레지스터와 RAM 과 중앙처리장치 CPU</title>
      <link>https://mj-seok.com/cs/cs-ram/</link>
      <pubDate>Mon, 02 Mar 2020 15:59:54 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/cs-ram/</guid>
      <description>Arithmetic and Logic Unit(ALU)  이진수를 입력받아 계산  레지스터와 RAM  AND-OR LATCH GATED LATCH 레지스터: 래치를 병렬로 사용하는 그룹  멀티플렉서  행 담당 열 담당 선택 SRAM(Static Random Access Memory)  Central Process Unit (CPU)  MICRO-ARCHITECTURE RAM : 16공간 x 8bit Register : 8bit x 4개 INSTRUCTION TABLE : id, opcode, address  레지스터 구성  Instruction Address Register Instruction Register Register A Register B Register C Register D  Instruction Table  Instruction / Description / 4-Bit Opcode / Address or Registers LOAD_A / Read RAM location (register A) / 0010 / 4-bit RAM address LOAD_B / Read RAM location (register B) / 0001 / 4-bit RAM address STORE_A / Write (register A) RAM location / 0100 / 4-bit RAM address ADD / Add two registers, store result / 1000 / 2-bit register ID, 2-bit register ID  FETCH PHASE (인출 단계)  Instruction Address Register -&amp;gt; ADDRESS INPUT RAM -&amp;gt; DATA -&amp;gt; Instruction Register  Decode Phase (해독 단계)  opcode 첫 4bit RAM 주소 뒤 4bit Instruction Register control unit  Execute Phase (실행 단계)  Load_A : RAM의 write enable 켜기 주소값 : RAM에서 위치에 DATA 값 확인 Load_A : Register A의 write enable 활성화 RAM Data : Register A에 저장 instruction 완성, 모든 연결선 종료 instruction address 레지스터 1증가 execute phase 종료 다음 instruction fetch 준비  Control Unit  Fetch Phase  Inst.</description>
    </item>
    
    <item>
      <title>컴파일러 - Compiler</title>
      <link>https://mj-seok.com/cs/compiler/</link>
      <pubDate>Mon, 02 Mar 2020 15:45:15 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/compiler/</guid>
      <description>컴파일러 과목  course output(CO) 언어번역기(컴파일러)의 필요성과 컴파일러 관련 이론을 습득합니다. 문법 이론과 오토마타 이론을 배웁니다. 어휘분석과 파싱 방법론을 습득합니다. 컴파일러 자동화 도구의 사용법을 배웁니다.  1장 컴파일러 개론    컴파일러와 인터프리터의 차이점을 설명할 수 있습니다.    JIT와 AOT 컴파일을 이해하고 그 필요성을 설명할 수 있습니다.    Preprocessor의 기능과 조건부 컴파일의 필요성을 이해하고, 설명할 수 있습니다.    컴파일러의 일반적인 구조와 주요 기능을 설명할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Develop Process</title>
      <link>https://mj-seok.com/cs/develop-process/</link>
      <pubDate>Mon, 02 Mar 2020 14:50:40 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/develop-process/</guid>
      <description>주요 개발 프로세스  Incremental Model  Divide and conquer 장점 : Waterfall Lifecycle Model과 같은 방식의 한계 극복 value를 분해하여 높은 value의 functionality를 초기 단계에 Increment에 assign함 각 Increment / build 개발 비용 및 기간 예측    Icremental Model    Implement and test first build   핵심 기능을 first increment에 넣어 개발    Implement, integrate and test successive build until product is complete    Maintenance    Spiral Model  리스크가 많은 프로젝트를 개발하는 데 가장 적합한 모델 Risk-Driven Model  리스크의 결과에 따라서 여러 루프가 하나의 phase를 나타냄   PROTOTYPE은 하나의 옵션일 뿐!</description>
    </item>
    
    <item>
      <title>최단경로 알고리즘 - Shortest Path Problem 2</title>
      <link>https://mj-seok.com/algorithm/spp2/</link>
      <pubDate>Mon, 02 Mar 2020 10:41:18 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/spp2/</guid>
      <description>최단경로 알고리즘 - Shortest Path Problem 2  벨만포드 알고리즘 모든 에지들에 대해서 릴렉스 하는 연산 최악의 경우 총 n - 1번  BELLMAN-FORD(G, w, s) INITIALIZE-SINGLE-SOURCE(G, s) for i &amp;lt;- 1 to |V[G]| - 1 do for each edge(u, v) ∈ E[G] do RELAX(u, v, w) for each edge(u, v) ∈ E[G] do if d[v] &amp;gt; d[u] + w(u, v) then return FALSE return TRUE  음수 사이클이 존재한다는 의미 시간복잡도 O(nm)  Dijkstra의 알고리즘  d[s] = 0 음수 가중치가 없다고 가정 s로부터의 최단경로의 길이를 이미 알아낸 노드들의 집합 s를 유지.</description>
    </item>
    
    <item>
      <title>Rdb</title>
      <link>https://mj-seok.com/database/rdb/</link>
      <pubDate>Fri, 28 Feb 2020 13:39:56 +0900</pubDate>
      
      <guid>https://mj-seok.com/database/rdb/</guid>
      <description>관계형 데이터베이스  논리적 설계  논리적 설계는 ER 다이어그램을 데이터베이스 관리 시스템에 매핑(Mapping, 사상)하는 것   관계형 데이터베이스의 용어와 식별자 유형  관계(테이블 또는 릴레이션)  테이블이라는 이름으로 사용 관계의 행은 튜플, 열은 애트리뷰트라고 하며 실제 데이터의 값이 들어감   튜플(레코드 또는 행)  관계를 구성하는 각각의 행을 의미하며, 애트리뷰트의 모임으로 구성   애트리뷰트(속성 또는 열)  데이터베이스를 구성하는 가장 작은 논리적 단위이며, 개체의 특성을 기술   도메인  애트리뷰트가 취할 수 있는 같은 타입의 원자 값들의 집합을 의미 실제 애트리뷰트 값이 나타날 때, 그 값의 적절성을 시스템이 판단하는 데 이용     요구사항 분석 -&amp;gt; 개념적 설계(ERD) -&amp;gt; 논리적 설계(정규화) -&amp;gt; 물리적 설계(성능(인덱스/저장구조)) -&amp;gt; 구현  관계형 데이터베이스의 용어와 식별자 유형  슈퍼키  관계에서 같은 튜플이 발생하지 않는 키를 구성할 때, 애트리뷰트의 집합으로 구성하는 것 유일성을 만족하는 애트리뷰트들의 집합   후보키  관계를 구성하는 애트리뷰트들 중에서 튜플을 유일하게 식별하려고 사용하는 애트리뷰튜들의 부분 집합, 즉 기본키로 사용할 수 있는 애트리뷰트들을 의미 슈퍼키 중 최소성 만족하는 키   기본키  후보키 중에서 선택한 주 키 널(Null)을 값으로 가질 수 없음 동일한 값이 중복해서 저장될 수 없음   대체키  후보키 중에서 선택되지 못한 키   외래키  관계를 맺는 두 릴레이션에서 참조하는 릴레이션에 애트리뷰트로 지정되는 키 값을 말함    관계형 데이터베이스에서의 제약조건  참조 무결성 제약조건  한 릴레이션에 있는 튜플이 다른 릴레이션에 있는 튜플을 참조하려면 반드시 참조되는 튜플이 해당 릴레이션 내에 있어야 한다는 것을 의미   키 제약 조건  키 애트리뷰트의 값은 릴레이션 내의 각 튜플을 유일하게 식별해야 함   도메인 제약 조건  각 애트리뷰트의 값은 반드시 도메인에 속하는 원자 값이어야 함    제약조건의 위배에 따른 처리  삽입 연산  삽입되는 튜플의 애트리뷰트 값이 도메인에 없으면 도메인 제약조건을 위반함   삭제 연산  다른 테이블에서 참조하고 있는 튜플을 삭제하면 참조 무결성 제약조건을 위반함   수정 연산  수정 연산은 기본적으로 삭제 연산 후 삽입 연산이 이루어지는 것이므로 삽입과 삭제 시의 문제점이 모두 나타남   제한(restricted)  위배를 야기한 연산을 단순히 거절   연쇄  참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제   널 값(nullify)  참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 이 튜플을 참조하는 튜플들의 외래키에 널 값을 삽입   디폴트 값  널 값을 넣는 대신에 디폴트 값을 넣는다는 것을 제외하고는 바로 위의 옵션과 비슷함    관계형 스키마 작성  개념적 설계 : 개념 스키마(ER 다이어그램) 논리적 설계 : 논리적 스키마(관계형 스키마)  ER 다이어그램을 관계형 스키마로 매핑하는 변환 과정  1단계: 엔티티 타입의 변환 2단계: 약한 엔티티 타입의 변환 3단계: 관계 타입(1:1)의 변환 4단계: 관계 타입(1:N)의 변환 5단계: 관계 타입(M:N)의 변환 6단계: 다치 애트리뷰트의 변환 7단계: N차 관계타입의 변환  엔티티 타입을 관계형 스키마로 매핑  엔티티 E1에 대해서 E1의 기본키를 포함한 모든 단순 애트리뷰트를 포함하는 릴레이션 E1를 생성한 것 애트리뷰트 B는 유도된 애트리뷰트 ER 다이어그램을 관계형 스키마로 매핑할 때 모든 단계에서 유도된 애트리뷰트는 릴레이션에 포함할 것인가 포함하지 않을 것인가는 설계자의 선택에 달림  약한 엔티티 타입을 관계형 스키마로 매핑  소유 엔티티 E1을 갖는 약한 엔티티 E2에 대해 모든 단순 애트리뷰트를 포함시키고, E1의 기본키를 외래키로 하는 릴레이션 E2를 생성한 것 (복합키)  1:1 관계 타입의 변환  릴레이션 E2는 앞의 단계에서 변환된 대로 남아 있고 릴레이션 E1은 앞의 단계에 변환된 내용에 관계 타입에서 변환된 내용이 추가됨 즉, 관계 타입이 변환되면서 외래키 D가 추가되고, 관계 타입의 애트리뷰트인 C가 추가됨  1:N 관계 타입의 변환  1:N 관계를 맺은 엔티티 타입 E1과 E2와 관계 타입 R이 있음 N측에 해당하는 것은 엔티티 타입 E2이므로 E1에 있는 기본키를 E2에 대응하는 릴레이션의 외래키로 포함시킴  M:N 관계 타입의 변환  두 엔티티 E1가 E2는 이진 M:N 관계 변환 규칙에 의해 관계 R은 릴레이션 R로 변환됨 R의 애트리뷰트였던 C는 릴레이션 R의 애트리뷰트가 됨 관계에 참여했던 E1의 기본키 A와 E2의 기본키 D는 릴레이션 R의 외래키로 참여하게 됨 외래키 A와 D의 조합은 릴레이션 R의 기본키가 됨  다치 애트리뷰트를 관계형 스키마로 매핑  다치 애트리뷰트에 대해 새로운 릴레이션을 생성하고, 다치 애트리뷰트를 포함시킴 A가 속해 있던 엔티티 타입 E1의 기본키인 PK를 외래키로 참여시킴 그리고 이 둘을 조합해서 릴레이션 A의 기본키로 둠  3차 관계 타입을 관계형 스키마로 매핑  3개의 엔티티 타입과 N차 관계 타입을 갖는 R이 존재함 각 엔티티를 릴레이션으로 변환 후, N차 관계 타입 R에 대응하는 릴레이션 R을 생성 관계 R의 애트리뷰트인 C1는 릴레이션 R의 애트리뷰트가 되고, 관계 타입 R에 연결되어 있는 모든 엔티티 타입의 키 애트리뷰트들은 조합해서 R의 키가 되고, 각각은 외래키가 됨  ER 다이어그램과 관계 모델과의 대응 관계  ER 모델 : 관계 모델 엔티티 타입 : 릴레이션 1:1 또는 1:N 관계 타입 : 외래키(또는 관계 릴레이션) M:N 관계 타입 : 릴레이션과 두 외래키 N차 관계 타입 : 관계 릴레이션과 N개의 외래키 단순 애트리뷰트 : 애트리뷰트 복합 애트리뷰트 : 단순 애트리뷰트들의 집합 다치 애트리뷰트 : 릴레이션과 외래키 값의 집합 : 도메인 키 애트리뷰트 : 기본키  </description>
    </item>
    
    <item>
      <title>최단경로 알고리즘 - Shortest Path Problem</title>
      <link>https://mj-seok.com/algorithm/spp/</link>
      <pubDate>Fri, 28 Feb 2020 12:32:26 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/spp/</guid>
      <description>최단경로  가중치 (방향) 그래프 G=(V, E), 즉 모든 에지에 가중치가 있음 경로 p=(V(0), V(1), &amp;hellip;, V(k))의 길이는 경로상의 모든 에지의 가중치의 합 노드 u에서 v까지의 최단경로의 길이를 S(u, v)라고 표시하자.  최단경로문제의 유형  Single-source:  하나의 출발 노드 s로부터 다른 모든 노드까지의 최단 경로를 찾아라. 예 : Dijkstra의 알고리즘   Single-destination:  모든 노드로부터 하나의 목적지 노드까지의 최단 경로를 찾아라. single-source 문제와 동일   Single-pair:  주어진 하나의 출발 노드 s로 부터 하나의 목적지 노드 t까지의 최단 경로를 찾아라 최악의 경우 시간복잡도에서 single-source 문제보다 나은 알고리즘이 없음   All-pairs:  모든 노드 쌍에 대해서 최단 경로를 찾아라.</description>
    </item>
    
    <item>
      <title>소프트웨어 프로세스 모델 - SW Process Model</title>
      <link>https://mj-seok.com/cs/sw-process/</link>
      <pubDate>Thu, 27 Feb 2020 13:24:19 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/sw-process/</guid>
      <description>소프트웨어 프로세스 모델 - SW Process Model  Process Model  1. Build-and-Fix Model  개발조직의 Process Model을 준수하지 않고, 요구사항 확인 후 바로 코딩으로 들어가는 경우  Ad-hoc Process Model   스펙이나 디자인이 없음   유지보수 시 결함 위치를 발견하기 어려운 모델 개발 시간 및 비용이 많이 듬    사용을 권하지 않으나 현재에도 많은 조직에서 활용 됨     Build First Version : 요구사항으로 First Version을 만듦 Modify until client is satisfied : Client 또는 Customer에게 보여주어 만족시킬 때까지 계속적으로 요구사항을 받아들임 Maintenance : Release한 후 유지보수 함 프로젝트 매니지먼트 관점에서 예측하기 어려운 모델    과연 어떤 행위를 다음에 해야 하는가?</description>
    </item>
    
    <item>
      <title>MST 알고리즘 - Prim의 알고리즘</title>
      <link>https://mj-seok.com/algorithm/algo-prim/</link>
      <pubDate>Mon, 24 Feb 2020 13:59:28 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-prim/</guid>
      <description>MST 알고리즘 - Prim의 알고리즘  임의의 노드를 출발노드로 선택 출발 노드를 포함하는 트리를 점점 키워 감. 매 단계에서 이미 트리에 포함된 노드와 포함되지 않은 노드를 연결하는 에지들 중 가장 가중치가 작은 에지를 선택   A = zero safe |A| = n - 1
 왜 MST가 찾아지는가?  Prim의 알고리즘의 임의의 한 단계를 생각해보자. A를 현재까지 알고리즘이 선택한 에지의 집합이라고 하고, A를 포함하는 MST가 존재한다고 가정하자. 출발 노드에 이미 연결된 노드와 그렇지 않은 노드를 연결하는 에지들 중 lightest edge  가중치가 최소인 에지 찾기  V(A) : 이미 트리에 포함된 노드들 V(A) 에 아직 속하지 않은 각 노드 v에 대해서 다음과 같은 값을 유지  key(v) : 이미 V(A) 에 속한 노드와 자신을 연결하는 에지들 중 가중치가 최소인 에지 (u, v)의 가중치 ㅠ(v) : 그 에지 (u, v)의 끝점 u   가중치가 최소인 에지를 찾는 대신 key값이 최소인 노드를 찾습니다.</description>
    </item>
    
    <item>
      <title>Elastic Search</title>
      <link>https://mj-seok.com/tech/es-1/</link>
      <pubDate>Wed, 19 Feb 2020 13:48:33 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/es-1/</guid>
      <description>Elastic Search  검색 및 분석 엔진 Logstash 와 Beats가 데이터 수집, 통합, 저장 Kibana 데이터 탐색, 시각화, 영감 공유 및 스택 모니터링 인덱싱, 검색, 분석을 강점으로 합니다.  데이터  문서 저장소입니다. 컬럼 로우로 저장하지 않고, JSON 문서로 시리얼라이즈해서 저장합니다. inverted index 자료 구조를 사용하여 거의 1초이내에 검색합니다.  </description>
    </item>
    
    <item>
      <title>Java Programming Language</title>
      <link>https://mj-seok.com/tech/java-1/</link>
      <pubDate>Wed, 19 Feb 2020 13:10:18 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/java-1/</guid>
      <description>Java Programming Language  특징  고수준 언어 간결합니다. 아키텍처 중립 객체 지향 멀티쓰레드    Software Development Process MyProgram.java - compiler -&amp;gt; MyProgram.class - Java VM -&amp;gt; My Program
 가상 머신 덕분에 다양한 플랫폼에서 동작 가능합니다. JAVA Application Programming Interface (API) Java Virtual Machine   플랫폼 독립전인 만큼 네이티브 코드보단 느릴 수 있지만 최근 기술 개선을 많이 이루어서 거의 비슷한 성능까지 끌어올렸다고 합니다.
 Java로 할 수 있는 것  개발 툴 : 컴파일, 러닝, 모니터링, 디버깅, 문서화 API : 애플리케이션에 사용할 수 있도록 만들어진 핵심 기능 및 유용한 클래스들 배포 기술 : 표준 구조 제공 유저 인터페이스 툴킷 : JavaFX, Swing등 통합 라이브러리 : 대표적으로 DB연결 라이브러리 등  Java가 돕는 것  쉽게 시작하게 합니다 적은 코드를 쓰게 합니다.</description>
    </item>
    
    <item>
      <title>데이터베이스 - 개념적인 설계</title>
      <link>https://mj-seok.com/database/database-2/</link>
      <pubDate>Tue, 18 Feb 2020 12:52:19 +0900</pubDate>
      
      <guid>https://mj-seok.com/database/database-2/</guid>
      <description>데이터베이스 - 개념적인 설계 엔티티-관계 모델  널리 사용되는 개념적 데이터 모델 엔티티(Entity), 애트리뷰트(Attribute), 관계(Relationship)를 이용해서 실세계를 개념적으로 표현하는 기법 ER 다이어그램은 데이터베이스 설계를 쉽게 할 수 있기 때문에 현재 많은 개념적인 설계에서 사용됨 ER 다이어그램을 이용하면 사용자의 요구 사항을 반영하여 비전문가인 사용자를 쉽게 이해 시킬 수 있음 ER 다이어그램을 그리는 설계 도구로는 ER win, ER Studio, Power Builder, DA# 등의 도구가 있지만, 본 교육에서는 DA#을 다룰 예정  ER 모델의 구성요소  엔티티(Entity) - 사각형, 판매자 애트리뷰트(Attribute) - 타원형, 아이디(기본키, 밑줄), 회사명, 사업자번호 관계(Relationship) - 마름모 모양, 엔티티 간의 관계  엔티티  실제로 존재하는 대상과 개념적으로 존재하는 대상 ER모델에서 가장 기본이 되며, 고유하게 식별 되어야 함 사람, 장소, 사물, 사건, 개념 등과 같이 현실 세계에 존재하면서 데이터베이스화 하였을 때 유용한 정보를 제공  엔티티 타입(Entity Type)  여러 엔티티가 모여서 하나의 집단을 이룬 형태 ER 다이어그램에서 엔티티 타입은 사각형으로 표현  강한 엔티티 타입  자신의 키 애트리뷰트가 있는 엔티티 타입 보통 말하는 엔티티 타입  약한 엔티티 타입  자신의 키 애트리뷰트가 없는 엔티티 타입 엔티티로 볼 수는 있지만 다른 엔티티에 종속되어 해당 엔티티가 없다면 존재하지 않는 종속성을 가지는 엔티티 이중 선 사각형으로 표현  애트리뷰트  엔티티 또는 관계가 갖는 성질이나 특성 보통 엔티티는 하나 이상의 키 애트리뷰트를 가지고 있어 나머지 애트리뷰트를 유일하게 정의할 수 있음 ER 다이어그램에서 애트리뷰트는 타원으로 표현 기본키는 밑줄을 칩니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 기초 정리</title>
      <link>https://mj-seok.com/algorithm/algo-1/</link>
      <pubDate>Mon, 17 Feb 2020 11:49:56 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-1/</guid>
      <description>알고리즘 - 기초 정리  주어진 문제를 명확히 하는 것! 모든 경우의 수를 다 순차 검색하는 것이 기장 기본적이라고 생각할 수 있습니다.  정렬이 된 경우라면?  오름차순, 내림차순으로 정렬을 합니다.  const BinarySearch = 그리디(탐욕) 알고리즘 const GreedySearch = function (changes, won) { for (let i = 0; i &amp;lt; changes.length; i++) { } } 오울러 트레일  아무거나 먼저 시작하기 미리 보기 전략  const EulerTrail = if cycle 미로 찾기  백트래킹 오일러 서킷  가짜 코인  어떤 코인이 함량이 낮은가?</description>
    </item>
    
    <item>
      <title>데이터베이스 기본</title>
      <link>https://mj-seok.com/database/database-1/</link>
      <pubDate>Sun, 16 Feb 2020 12:29:40 +0900</pubDate>
      
      <guid>https://mj-seok.com/database/database-1/</guid>
      <description>데이터베이스 기본  여러 사람 또는 응용 시스템들이 공유할 목적으로 구조화 하여 관리하는 데이터들의 집합 컬럼, 열, 속성, 어트리뷰트 행, 레코드, 튜플  데이터베이스 관리 시스템  데이터베이스 : 효율적으로 저장하는 저장소 데이터베이스 관리 시스템 (DBMS, Database Management System) 데이터베이스를 편리하고 효율적으로 관리하기 위해 필요한 기능을 집대성한 소프트웨어 패키지 오리클사의 Oracle과 MySQL 마이크로소프트사의 SQL Server 사용자가 데이터베이스 관리 시스템을 통하여 물리적인 데이터베이스와 소통하는 형태의 시스템  응용 프로그램 DBMS Database</description>
    </item>
    
    <item>
      <title>컴퓨터 과학 - Computer Science</title>
      <link>https://mj-seok.com/cs/cs-1/</link>
      <pubDate>Sat, 15 Feb 2020 18:40:43 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/cs-1/</guid>
      <description>컴퓨터 과학 - Computer Science  2500년 전 주판 : 계산의 상태 기록 1600년 대 : 컴퓨터 직업에 대한 표현 1800년 대 : 컴퓨터 기계로 표현  계전기  릴레이, 수도꼭지같이 열었다 닫았다 합니다. 컴퓨터 버그 - 진기 기계씩 릴레이 기계에 붙어있는 벌레  열 이온 밸브(진공관)  다이오드 : 한쪽으로 호르는 전기 전자 기계식 컴퓨팅 -&amp;gt; 전자 컴퓨팅 ENIAC : 전자 컴퓨터 시작 트랜지스터 : 전류를 흐르게 하거나 멈추게 합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 최소비용 신장 트리(MST)</title>
      <link>https://mj-seok.com/algorithm/algo-mst/</link>
      <pubDate>Sat, 15 Feb 2020 16:44:18 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-mst/</guid>
      <description>알고리즘 - 최소비용 신장 트리(MST)  입력 : n개의 도시, 도시와 도시를 연결하는 비용 문제 : 최소의 비용으로 모든 도시들이 서로 연결되게 합니다.  최소비용 신장 트리 (Minimum Spanning Tree)  해가 유일하지는 않음 무방향 가중치 그래프 G=(V,E) 각 에지 (u, v) &amp;lt; E 에 대해서 가중치 w(u, v) 문제 : 다음과 같은 조건을 만족하는 에지들의 부분집합 T &amp;lt; E 를 찾자.    T에 속한 에지들에 의해 그래프의 모든 정점들이 서로 연결됩니다.</description>
    </item>
    
    <item>
      <title>Webpack 개념</title>
      <link>https://mj-seok.com/tech/webpack-intro/</link>
      <pubDate>Fri, 14 Feb 2020 17:13:46 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/webpack-intro/</guid>
      <description>[Reference] : https://webpack.js.org/concepts/
Webpack 개념  모던 자바스크립트 애플리케이션을 위한 정적 모듈 번들러  핵심 개념  Entry (시작점) Output (출력) Loaders (로더) Plugins (플러그인) Mode (모드) Browser Compatibility (브라우저 호환성)  Entry  entry point : 내부 의존성 그래프가 빌드하기 시작하는 지점을 표기   webpack.config.js
 module.exports = { entry: &amp;#39;./path/to/my/entry/file.js&amp;#39; }; Output  output : 번들된 곳을 방출하는 위치   webpack.config.js
 const path = require(&amp;#39;path&amp;#39;); module.</description>
    </item>
    
    <item>
      <title>DAG(Directed Acyclic Graph)</title>
      <link>https://mj-seok.com/algorithm/algo-dag/</link>
      <pubDate>Fri, 14 Feb 2020 16:15:40 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-dag/</guid>
      <description>DAG(Directed Acyclic Graph)  방향 사이클(directed cycle)이 없는 방향 그래프. 예: 작업들의 우선순위  위상정렬(topological ordering)  DAG에서 노드들의 순서화 v(1), v(2), v(3), &amp;hellip; v(n), 단, 모든 에지(v(i), v(j))에 대해서 i &amp;lt; j가 되도록. 일반적으로 답이 유일하지 않습니다.  위상정렬 알고리즘 1   들어오는 edge : incoming edge
  그 갯수 : indegree
  나가는 edge : outgoing edge
  그 갯수 : outdegree
   indegree가 0인 노드를 찾습니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 깊이우선순회(DFS)</title>
      <link>https://mj-seok.com/algorithm/algo-dfs/</link>
      <pubDate>Tue, 11 Feb 2020 12:02:13 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-dfs/</guid>
      <description>알고리즘 - 깊이우선순회(DFS)  이진트리 순회 방법  in-order(dfs) pre-order(dfs) post-order(dfs) level-order(bfs)     출발점 s에서 시작합니다.    현재 노드를 visited로 mark하고 인접한 노드들 중 unvisited 노드가 존재하면 그 노드로 갑니다.    2번을 계속 반복합니다.    만약 unvisited인 이웃 노드가 존재하지 않는 동안 계속해서 직전 노드로 되돌아갑니다.    다시 2번을 반복합니다.    시작노드 s로 돌아오고 더 이상 갈 곳이 없으면 종료합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 그래프 순회 (Graph Traversal)</title>
      <link>https://mj-seok.com/algorithm/algo-bfs/</link>
      <pubDate>Tue, 11 Feb 2020 11:57:36 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-bfs/</guid>
      <description>알고리즘 - 그래프 순회 (Graph Traversal)  순회(traversal) 그래프의 모든 노드들을 방문하는 일 대표적 두 가지 방법 BFS (Breadth-First Search, 너비우선순회) DFS (Depth-First Search, 깊이우선순회)  너비우선순회 (BFS)  BFS 알고리즘은 다음 순서로 노드들을 방문 L(0) = {s}, 여기서 s는 출발 노드 L(1) = L(0)의 모든 이웃 노드들 L(2) = L(1)의 이웃들 중 L(0)에 속하지 않은 노드들 &amp;hellip; L(i) = L(i - 1)의 이웃들 중 L(i - 2)에 속하지 않는 노드들 동심원 형태  큐를 이용한 너비우선순회  s = 1 체크는 이미 방문된 노드라는 표시   check the start node;    insert the start node into the queue;    while the queue is not empty do remove a node v from queue; for each unchecked neighbour w of v do check and insert w into the queue; 너비우선순회 BFS(G, s)	// 그래프 G와 출발 노드 s Q &amp;lt;- empty queue; Enqueue(Q, s); while Q =/ empty do u &amp;lt;- Dequeue(Q) for each v adjacent to u do if v is unvisited then mark v as visited; Enqueue(Q, v); end.</description>
    </item>
    
    <item>
      <title>알고리즘 - 그래프 알고리즘</title>
      <link>https://mj-seok.com/algorithm/algo-graph/</link>
      <pubDate>Sun, 09 Feb 2020 15:01:49 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-graph/</guid>
      <description>알고리즘 - 그래프 알고리즘  개념과 표현  그래프 (Graph)  (무방향) 그래프 G = (V, E) // 두 개의 집합에 의해서 정의되는 구조 V : 노드(node) 혹은 정점(vertex) // 정점의 집합 E : 노드쌍을 연결하는 에지(edge) 혹은 링크(link) // 정점과 정점을 연결하는 에지들의 집합 개체(object)들 간의 이진관계를 표현 n = |V|, m = |E|  V = {1, 2, 3, 4, 5, 6, 7, 8} E = {(1, 2), (1, 3), (2, 3), &amp;hellip;, (7, 8)} n = 8 (정점의 개수) m = 11 (에지의 개수)    방향 그래프와 가중치 그래프  방향그래프(Directed Graph) G = (V, E)  에지 (u, v)는 u로부터 v로의 방향을 가짐   가중치(weighted) 그래프  에지마다 가중치(weight)가 지정    다중 엣지 와 셀프 엣지  다중 엣지 : 엣지 집합, 집합이기 때문에 중복 값이 들어가면 안 됩니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 해싱 Hashing</title>
      <link>https://mj-seok.com/algorithm/algo-hashing/</link>
      <pubDate>Wed, 05 Feb 2020 11:09:52 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-hashing/</guid>
      <description>알고리즘 - 해싱 Hashing  해쉬 테이블은 dynamic set을 구현하는 효과적인 방법의 하나 적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O(1) 보통 최악의 경우 O(n)  Hash Table  해쉬 함수(hash function) h를 사용하여 키 k를 T[h(k)]에 저장  h : U -&amp;gt; {0, 1, &amp;hellip;, m - 1}, U : 양의 정수들의 집합 여기서 m은 테이블의 크기, U는 모든 가능한 키들의 집합   키 k가 h(k)로 해슁되었다고 말함. 해쉬테이블은 일반적으로 하나의 배열 즉 각 키에 대한 해쉬함수값을 그 키를 저장할 배열 인덱스로 사용  index = h(k: a key) h(X) = x % m 0 .</description>
    </item>
    
    <item>
      <title>알고리즘 - 레드 블랙 트리</title>
      <link>https://mj-seok.com/algorithm/algo-rb/</link>
      <pubDate>Tue, 04 Feb 2020 12:06:23 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-rb/</guid>
      <description>알고리즘 - 레드 블랙 트리  이진탐색트리의 일종 균형잡힌 트리 : 높이가 O(log(2)n) SEARCH, INSERT, DELETE 연산을 최악의 경우에도 O(log(2)n) 시간에 지원  레드-블랙 트리  각 노드는 하나의 키(key), 왼쪽자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장 자식노드가 존재하지 않을 경우 NIL 노드라고 부르는 특수한 노드가 있다고 가정 따라서 모든 리프노드는 NIL노드 루트의 부모도 NIL노드라고 가정 노드들은 내부노드와 NIL노드로 분류  레드-블랙 트리: 정의  다음의 조건을 만족하는 이진탐색트리 : 각 노드는 red 혹은 black이고, 루트노드는 black이고, 모든 리프노드(즉, NIL노드)는 black이고, red노드의 자식들은 전부 black이고(즉, red노드는 연속되어 등장하지 않고), 모든 노드에 대해서 그 노드로부터 자손인 리프노드에 이르는 모든 경로에는 동일한 개수의 black노드가 존재합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 이진검색트리(Binary Search Tree)</title>
      <link>https://mj-seok.com/algorithm/algo-binary-search-tree/</link>
      <pubDate>Thu, 30 Jan 2020 12:48:31 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-binary-search-tree/</guid>
      <description>알고리즘 - 이진검색트리(Binary Search Tree)  이진트리 순회하는 알고리즘 트리라는 자료구조 조직도, 가계도  Dynamic Set  저장하는 데이터 자체가 계층 구조가 아닌 일종의 컨테이너(집합) 여러 개의 키(key)를 저장 다음과 같은 연산들을 지원하는 자료구조 INSERT - 새로운 키의 삽입 SEARCH - 키 탐색 DELETE - 키의 삭제 예 : 심볼 테이블 called Dynamic Set Dictionary Search Structure  시간 복잡도  정렬 안 된 배열 검색 : 순차검색 O(n) 정렬 안 된 배열 삽입 : 맨 뒤 O(1) 배열 복사 이동 고려 O(n) 정렬 안 된 배열 삭제 : 검색 고려하지 않고 마지막 데이터와 교체 O(1) 정렬된 배열 검색 : 이진검색 O(logn) 정렬된 배열 삽입 : 다른 값 위치 shift O(n) 정렬된 배열 삭제 : 다른 값 위치 shift O(n) 정렬 안 된 연결 리스트 검색 : O(n) 정렬 안 된 연결 리스트 삽입 : 맨 앞 O(1) 정렬 안 된 연결 리스트 삭제 : 검색 고려하지 않고 마지막 데이터와 교체 O(1) 정렬된 연결 리스트 검색 : n / 2 바로 탐색 불가 O(n) 정렬된 연결 리스트 삽입 : O(n) 정렬된 연결 리스트 삭제 : O(1)  다양한 방법들  정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n) 이진탐색트리(Binary Search Tree), 레드-블랙 트리, AVL-트리 등의 트리에 기반한 구조들 Direct Address Table, 해쉬 테이블 등  검색트리  Dynamic set을 트리의 형태로 구현 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 가짐 이진검색트리(Binary Search Tree), 레드-블랙 트리(red-black tree), B-트리 등  이진검색트리 (BST)  이진 트리이면서 각 노드에 하나의 키를 저장 각 노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같습니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 트리와 이진트리</title>
      <link>https://mj-seok.com/algorithm/algo-tree/</link>
      <pubDate>Thu, 30 Jan 2020 11:45:59 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-tree/</guid>
      <description>알고리즘 - 트리와 이진트리  계층적인 구조를 표현 조직도 디렉토리와 서브디렉토리 구조 가계도  맨 위의 노드 : 루트(root)  트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨 노드들을 연결하는 선을 &amp;ldquo;link&amp;rdquo;, &amp;ldquo;edge&amp;rdquo;, &amp;ldquo;branch&amp;quot;등으로 부름  부모-자식 관계  부모(parent) 노드 : animal 자식(child) 노드 : cat, fox, wolf  형제 관계  루트노드를 제외한 트리의 모든 노드들은 유일한 부모 노드를 가짐 부모가 동일한 노드들을 형제(sibling) 관계라고 부름  리프(leaf) 노드  리프노드가 아닌 노드들을 내부(internal)노드라고 부름 자식이 없는 노드들을 leaf노드라고 부름  조상 - 자손 관계  조상(ancestor) 노드 : animal 자손(descendant) 노드 : canine 부모 - 자식 관계를 확장한 것이 조상 - 자손 (ancestor - descendant) 관계입니다.</description>
    </item>
    
    <item>
      <title>알고리즘 Java에서의 정렬</title>
      <link>https://mj-seok.com/algorithm/algo-java-sort/</link>
      <pubDate>Wed, 29 Jan 2020 12:26:07 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-java-sort/</guid>
      <description>[알고리즘] Java에서의 정렬  Arrays클래스가 primitive타입 데이터를 위한 정렬 메서드를 제공  int[] data = new int[capacity]; // data[0]에서 data[capacity - 1]까지 데이터가 꽉 // 차있는 경우에는 다음과 같이 정렬합니다. Arrays.sort(data); // 배열에 꽉 차있지 않고 data[0]에서 data[size - 1]까지 // size개의 데이터만 있다면 다음과 같이 합니다. Arrays.sort(data, 0, size);  int 이외의 다른 primitive 타입 데이터(double, char 등)에 대해서도 제공  객체의 정렬 : 문자열 String [] fruits = new String[] { &amp;#34;Pineapple&amp;#34;, &amp;#34;Apple&amp;#34;, &amp;#34;Orange&amp;#34;, &amp;#34;Banana&amp;#34; }; Arrays.</description>
    </item>
    
    <item>
      <title>알고리즘 - Radix Sort</title>
      <link>https://mj-seok.com/algorithm/algo-radix-sort/</link>
      <pubDate>Wed, 29 Jan 2020 12:02:51 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-radix-sort/</guid>
      <description>Radix Sort  n개의 d자리 정수들 가장 낮은 자리수부터 정렬  Stable Sort  동일한 데이터가 2개 이상 있다면 정렬 후에도 입력 순서가 출력 순서로 유지되야 합니다. Radix Sort 같은 경우는 반드시 Stable 해야 합니다.  RADIX-SORT(A, d) for i &amp;lt;- 1 to d do use a stable sort to sort array A on digit i  시간 복잡도 O(d(n+k)) 10진수 (k = 10) 알파벳 (k = 26)  정렬 알고리즘들  Bubble sort : O(n^2) Insertion sort : O(n^2) Selection sort : O(n^2) Quick Sort : worst O(n^2) and average O(nlog2n) Merge sort : O(nlog2n) Heap sort : O(nlog2n) Counting sort : O(n+k) Radix sort : O(d(n+k))  </description>
    </item>
    
    <item>
      <title>알고리즘 - 선형 시간 정렬</title>
      <link>https://mj-seok.com/algorithm/algo-sorting-linear/</link>
      <pubDate>Wed, 29 Jan 2020 10:44:39 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-sorting-linear/</guid>
      <description>선형 시간 정렬 Counting Sort  n개의 정수를 정렬하세요. 단 모든 정수는 0에서 k 사이의 정수입니다. 길이 k인 배열에 각 정수의 개수를 count합니다.  int A[n]; // 정렬할 데이터 0 ~ k int C[k] = {0, }; for ( int i=1; i&amp;lt;=n; i++ ) C[A[i]]++; for ( int s=1, i=0; i&amp;lt;=k; i++ ) { for ( int j=0; j&amp;lt;C[i]; j++ ) { A[s++] = i; } } COUNTING-SORT(A, B, k) for i &amp;lt;- 0 to k do C[i] &amp;lt;- 0 for j &amp;lt;- 1 to length[A] do C[A[j]] &amp;lt;- C[A[j]] + 1 &amp;gt; C[i] now contains the number of elements equal to i.</description>
    </item>
    
    <item>
      <title>Spring boot와 React.js의 만남 - 프론트엔드</title>
      <link>https://mj-seok.com/tech/spring-react-2/</link>
      <pubDate>Thu, 23 Jan 2020 10:28:36 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/spring-react-2/</guid>
      <description>Spring boot(백엔드)와 React.js(프론트엔드)의 만남 - 프론트엔드 1단계 UI Controller를 만들어봅시다.(Spring MVC Controller) package com.mjseok.springreact; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HomeController { @RequestMapping(value = &amp;#34;/&amp;#34;) public String index() { return &amp;#34;index&amp;#34;; } }  @Controller : Spring MVC Controller인 class에 마크합니다. @RequestMapping : index() 메소드에 / route를 도와줍니다. &amp;quot;index&amp;quot; template return =&amp;gt; 뷰 리졸버가 src/main/resources/templates/index.html 를 매핑합니다.  2단계 HTML 템플릿 만들기  src/main/resources/templates/index.html
 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html xmlns:th=&amp;#34;https://www.thymeleaf.org&amp;#34;&amp;gt; &amp;lt;head lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;/&amp;gt; &amp;lt;title&amp;gt;ReactJS + Spring Data REST&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/main.</description>
    </item>
    
    <item>
      <title>탐욕 알고리즘 - Greedy Algorithm</title>
      <link>https://mj-seok.com/algorithm/algo-greedy/</link>
      <pubDate>Wed, 22 Jan 2020 22:39:30 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-greedy/</guid>
      <description>탐욕 알고리즘 - Greedy Algorithm  현재 상황에서 가장 좋아 보이는 답을 선택하는 방법 각 부분에서 최적을 선택하면 전체에서도 최적이 될 것이라는 가정을 전제로 합니다. 선택은 항상 하위 문제에 대한 해답이 나오기 전에 선택됩니다.  탐욕 선택  하위 문제를 풀기 전에 선택을 합니다. 항상 하나의 문제만을 고려합니다.  동적 프로그래밍  하위 문제를 풀고 나서 선택을 합니다. 동시에 여러 개의 하위 문제를 고려합니다.  0-1 배낭 채우기 문제 (0-1 knapsack)  도둑이 상점에서 n개의 물건을 훔친다고 합니다.</description>
    </item>
    
    <item>
      <title>Spring boot와 React.js의 만남 - 백엔드</title>
      <link>https://mj-seok.com/tech/spring-react/</link>
      <pubDate>Wed, 22 Jan 2020 18:06:35 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/spring-react/</guid>
      <description>Spring boot(백엔드)와 React.js(프론트엔드)의 만남 [ Reference ] : https://spring.io/guides/tutorials/react-and-spring-data-rest/
[ Spring Initializr ] : https://start.spring.io/
1단계 Spring Initializr 아래의 Dependencies 를 추가해서 Generate 합니다.
 Rest Repositories Thymeleaf JPA H2  만들어진 스프링 프로젝트를 압축해제 합니다.
2단계 첫 java 파일 IDE로 스프링프로젝트를 엽니다.
 Spring Data REST 를 사용하므로 간편하게 작업할 수 있습니다.  domain 선언  Employee.java
 package com.mjseok.springreact; import java.util.Objects; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Employee { private @Id @GeneratedValue Long id; private String firstName; private String lastName; private String description; private Employee() {} public Employee(String firstName, String lastName, String description) { this.</description>
    </item>
    
    <item>
      <title>정렬 알고리즘 - Sort Algorithm</title>
      <link>https://mj-seok.com/algorithm/algo-sort/</link>
      <pubDate>Tue, 14 Jan 2020 11:13:38 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-sort/</guid>
      <description>정렬 알고리즘 - Sort Algorithm [ Reference ] : https://youtu.be/0dG7xTt5IfQ
 정렬이 가장 기본입니다.  간단하고, 느린 정렬 - Simple, Slow  Bubble sort Insertion sort Selection sort  빠른 정렬 - Fast  Quick sort Merge sort Heap sort  O(N) 근본적으로 다른 알고리즘  Radix sort  기본적인 정렬 알고리즘 선택 정렬 - Selection Sort  initial array = [29, 10, 14, 37, 13]; 가장 큰 값을 맨 마지막 값과 바꿉니다.</description>
    </item>
    
    <item>
      <title>정렬 알고리즘 2 - Sort Algorithm</title>
      <link>https://mj-seok.com/algorithm/algo-sort-2/</link>
      <pubDate>Tue, 14 Jan 2020 11:13:38 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-sort-2/</guid>
      <description>정렬 알고리즘 - Sort Algorithm [ Reference ] : https://youtu.be/0dG7xTt5IfQ
 정렬이 가장 기본입니다.  간단하고, 느린 정렬 - Simple, Slow  Bubble sort Insertion sort Selection sort  빠른 정렬 - Fast  Quick sort Merge sort Heap sort  O(N) 근본적으로 다른 알고리즘  Radix sort  힙 정렬 - Heap Sort  힙, 바이너리 힙 이진 힙 자료구조 정렬 최악의 경우 시간복잡도 O(nlog(2)n) Sorts in place - 추가 배열 불필요 이진 힙(binary heap) 자료구조를 사용  Heap의 정의  complete binary tree이면서, heap property 만족  Full vs Complete Binary Trees   full binary tree: 모든 레벨에 노드들이 꽉 차있는 형태</description>
    </item>
    
    <item>
      <title>알고리즘 멱집합 구하기 - powerSet</title>
      <link>https://mj-seok.com/algorithm/algo-powerset/</link>
      <pubDate>Tue, 14 Jan 2020 10:16:47 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-powerset/</guid>
      <description>멱집합 구하기 - powerSet private static char data[] = {&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;}; private static int n = data.length; private static boolean [] include = new boolean[n]; public static void powerSet(int k) { if (k==n) { for (int i=0; i&amp;lt;n; i++) if (include[i]) System.out.print(data[i] + &amp;#34; &amp;#34;); System.out.println(); return; } include[k] = false; powerSet(k+1); include[k] = true; powerSet(k+1); } </description>
    </item>
    
    <item>
      <title>AWS 키 페어 복구하기 - AWS Reset Key Pair</title>
      <link>https://mj-seok.com/tech/aws-reset-key/</link>
      <pubDate>Mon, 13 Jan 2020 12:29:26 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/aws-reset-key/</guid>
      <description>AWS 키 페어 복구하기 - AWS Reset Key Pair [Reference] : https://bactoria.github.io/2019/09/08/EC2-%ED%82%A4%ED%8E%98%EC%96%B4-%EB%B6%84%EC%8B%A4%ED%96%88%EC%9D%84-%EB%95%8C-%ED%95%B4%EA%B2%B0%EB%B2%95/
1. 인스턴스 이미지 생성  인스턴스 카테고리의 인스턴스 메뉴 클릭 - 복구할 인스턴스 오른쪽 클릭 - 이미지 - 이미지 생성  2. 이미지 시작하기 (새 인스턴스 만들기)  이미지 카테고리의 AMI 메뉴 클릭 - 시작하기 - 검토 및 시작  이 때 만들어지는 key pair pem 파일을 잘 간수합니다.
3. 기존 EC2 인스턴스 중지  인스턴스 카테고리의 인스턴스 메뉴 클릭 - 복구할 인스턴스 오른쪽 클릭 - 인스턴스 상태 - 중지  4.</description>
    </item>
    
    <item>
      <title>알고리즘의 기본 - Algorithm Basic</title>
      <link>https://mj-seok.com/algorithm/algorithm-desc/</link>
      <pubDate>Sun, 12 Jan 2020 13:44:48 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algorithm-desc/</guid>
      <description>알고리즘의 기본 - Algorithm Basic [ Reference ] : https://www.youtube.com/watch?v=qQ5iLNjpxSk&amp;amp;list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz
알고리즘이란 &amp;lsquo;문제를 해결하는 절차&#39;입니다  입력, 출력, 유한성, 명백성, 효과성을 만족해야 합니다. 분석을 통해 좋고 나쁨을 평가할 수 있습니다. 기초 프로그래밍과 자료구조를 공부한 이후에 배우면 좋습니다. 논리이며 수학이고, 실질적인 개발에 적용되는 기초적인 아이디어입니다.   점근적 분석법, 행렬? 버블정렬, 선택정렬 보다 퀵 정렬이 빠르게 수행됩니다.
 알고리즘은 &amp;lsquo;개발&#39;의 전체 과정에 사용됩니다  실제 프로그램을 개발할 때 효율적인 알고리즘을 적용함으로써 원하는 결과를 도출해야 합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - N-Queens Problem</title>
      <link>https://mj-seok.com/algorithm/algo-nqueens/</link>
      <pubDate>Sat, 11 Jan 2020 14:24:45 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-nqueens/</guid>
      <description>알고리즘 - N-Queens Problem  N x N 체스 보드 N = 8 동일한 행, 동일한 대각선, 동일한 열 빼놓고 말을 놓는 방법  4 x 4  하나의 행마다 정확히 하나의 말 서로 다른 경우의 수 : N의 N승 Backtracking : 최근에 내렸던 결정을 번복하고, 지나온 궤적을 되돌아 나간다.  상태 공간 트리  상태공간트리 : 찾는 해를 포함하는 트리. 즉, 해가 존재한다면 그것은 반드시 이 트리의 어떤 한 노드에 해당함 따라서 이 트리를 체계적으로 탐색하면 해를 구할 수 있음  상태 공간 트리의 모든 노드를 탐색해야 하는 것은 아님  (1,1) (2,1) -&amp;gt; non-promising (1,1) (2,2) -&amp;gt; infeasible: 꽝 (1,1) (2,3) -&amp;gt; continue&amp;hellip;  되추적 기법(Backtracking)  상태공간 트리를 깊이 우선 방식으로 탐색하여 해를 찾는 알고리즘  깊이 우선 탐색  recursion stack 자료구조 이용  Design Recursion // 매개변수는 내가 현재 트리의 어떤 노드에 있는지를 지정해야 한다.</description>
    </item>
    
    <item>
      <title>블롭 셀 카운팅 알고리즘 - Counting Cells in a Blob</title>
      <link>https://mj-seok.com/algorithm/algo-countcell/</link>
      <pubDate>Sat, 11 Jan 2020 13:42:06 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-countcell/</guid>
      <description>블롭 셀 카운팅 알고리즘 - Counting Cells in a Blob [ Reference ] : https://youtu.be/HHJFlVT1tBw
 Binary 이미지 각 픽셀은 background pixel이거나 image pixel Blob - 서로 연결된 image pixel들의 집합을 blob이라고 부름 상하좌우 및 대각방향으로도 연결된 것으로 간주  입력 :
 N x N 크기의 2차원 그리드(grid) 하나의 좌표 (x, y)  출력 :
 픽셀 (x, y)가 포함된 blob의 크기 (x, y)가 어떤 blob에도 속하지 않는 경우에는 0  Recursive Thinking 현재 픽셀이 이 속한 blob의 크기를 카운트하려면 현재 픽셀이 image color가 아니라면 // base case 0을 반환한다 현재 픽셀이 image color라면 먼저 현재 픽셀을 카운트한다 (count=1) 현재 픽셀이 중복 카운트되는 것을 방지하기 위해 다른 색으로 칠한다.</description>
    </item>
    
    <item>
      <title>미로찾기 알고리즘 - Maze Algorithm</title>
      <link>https://mj-seok.com/algorithm/algo-maze/</link>
      <pubDate>Fri, 10 Jan 2020 22:06:14 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-maze/</guid>
      <description>미로찾기 알고리즘 - Maze Algorithm Recursive Thinking
현재 위치에서 출구까지 가는 경로가 있으려면
 현재 위치가 출구이거나 혹은 이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가능 경로가 있거나  aa
미로찾기(Decision Problem - return yes or no) boolean findPath(x, y) if (x, y) is the exit return true; else for each neighbouring cell (x`, y`) of (x, y) do if (x`, y`) is on the pathway if findPath(x`, y`) return true; return false;  인접한 셀이 초기값과 무한 루프에 빠질 수 있습니다.</description>
    </item>
    
    <item>
      <title>ES6 - 적절한 꼬리 호출(Proper Tail Calls)</title>
      <link>https://mj-seok.com/javascript/ecma-ptc/</link>
      <pubDate>Wed, 08 Jan 2020 18:46:45 +0900</pubDate>
      
      <guid>https://mj-seok.com/javascript/ecma-ptc/</guid>
      <description>ECMAScript 6 - 적절한 꼬리 호출(Proper Tail Calls) https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/
적절한 꼬리 호출?(Proper Tail Calls)  Proper Tail Calls(PTC)는 ECMAScript 6 언어의 새로운 특징입니다. recursive 프로그래밍 패턴을 수월하게 하고자 추가됬다고 합니다. stack overflow exception 를 발생시키는 코드도 실행할 수 있게 한다고 합니다.  부연 설명  일반적으로 함수 호출할 때, 함수 호출과 관련된 데이터에 스택 공간을 할당합니다. 이 데이터에는 반환 주소, 이전 스택 포인터, 함수에 대한 전달인자, 로컬 값에 대한 공간(스택 프레임)등 있습니다.</description>
    </item>
    
    <item>
      <title>Javascript와 ECMAScript - 알아보기</title>
      <link>https://mj-seok.com/javascript/ecma-javascript/</link>
      <pubDate>Mon, 06 Jan 2020 23:50:45 +0900</pubDate>
      
      <guid>https://mj-seok.com/javascript/ecma-javascript/</guid>
      <description>Javascript와 ECMAScript - 알아보기 ECMAScript 와 JavaScript JavaScript https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript
 복잡한 무언가(주기적으로 내용이 갱신되는 기능이나 능동적인 지도, 변화하는 2D/3D 그래픽, 동영상 등)를 웹페이지에 적용할 수 있게 하는 스크립트 혹은 프로그래밍 언어입니다.  기본 작성 형태 // HTML 요소 중 p태그를 선택 const para = document.querySelector(&amp;#39;p&amp;#39;); para.addEventListener(&amp;#39;click&amp;#39;, updateName); function updateName() { //&amp;#39;Enter a new name&amp;#39;과 입력란 출력하여 입력받은 값을 name에 저장  let name = prompt(&amp;#39;Enter a new name&amp;#39;); // para(p태그)에 새로운 문자열 저장  para.</description>
    </item>
    
    <item>
      <title>Python - for in 문법</title>
      <link>https://mj-seok.com/tech/python-for/</link>
      <pubDate>Wed, 01 Jan 2020 17:51:58 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/python-for/</guid>
      <description>Python - for in 문법 Reference : https://youtu.be/0wpYyDlAEIg
 array, list, tuple, string 의 시퀀스를 출력  days = (&amp;#34;Mon&amp;#34;, &amp;#34;Tue&amp;#34;, &amp;#34;Wed&amp;#34;, &amp;#34;Thu&amp;#34;, &amp;#34;Fri&amp;#34;) for day in days: print(day) for day in [1, 2, 3, 4, 5]: print(day) for day in days: if day is &amp;#34;Wed&amp;#34;: break else: print(day) for letter in &amp;#34;Nicolas&amp;#34;: print(letter)   행복 코딩
 </description>
    </item>
    
    <item>
      <title>선형대수학(Linear Algebra) - 벡터(Vector) 와 튜플(Tuple)</title>
      <link>https://mj-seok.com/cs/math-linearalgebra/</link>
      <pubDate>Wed, 01 Jan 2020 17:22:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/cs/math-linearalgebra/</guid>
      <description>선형대수학(Linear Algebra) - 벡터(Vector) 와 튜플(Tuple) [ Reference ] : https://youtu.be/br7tS1t2SFE
 프론트엔드의 다양한 애니메이션과 프로그래밍에서 다양하게 응용된다는 선형대수학! 벡터 공간, 벡터, 선형 변환, 행렬, 연립 선형 방정식등을 연구하는 대수학의 한 분야라고 합니다.  벡터 Vector  크기 magnitud 방향 direction  속도(speed) - 5mph (크기) : 스칼라(scalar)
속력(velocity) - 동쪽 (east) 5mph (크기) : 벡터(vector)
v = (5, 0) = [5] [0] 길이 : 5 v = (3, 4) = [3] [4] 길이 : 5 (피타고라스 3^2 + 4^2 = 5^2) 튜플 Tuple |R R^2 실수좌표공간 Real Coordinate Space  실수값을 가지는 모든 2-튜플 튜플 : 순서가 정해진 리스트  R^3 : 3D real Coordinate space x = [0 0 0] b = [-1 5 2] c = [i(허수) 0 1]  R^n : n - dimensional real coordinate space   </description>
    </item>
    
    <item>
      <title>재귀 설계 - Design Recursion</title>
      <link>https://mj-seok.com/algorithm/algo-designrecursion/</link>
      <pubDate>Wed, 01 Jan 2020 15:54:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-designrecursion/</guid>
      <description>재귀 설계 - Design Recursion [ Reference ] : https://youtu.be/Vwfo_hrxuzg
 Recursion을 어떻게 짜야할까?  순환적 알고리즘 설계  적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함 (at least one base case) 모든 case는 결국 base case로 수렴해야 함  if () { return base_case; } else { recursion(); }  암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라.
 순차 탐색 (Sequential Search)  배열에 내가 원하는 특정한 값이 있는지 검사 데이터들이 정렬되있다면 이진 검색 정렬되어있지 않다면(순서 조건) 하나씩 순서대로 검사  int search(int [] data, int n, int target) { for (int i=0; i&amp;lt;n; i++) if (data[i] == target) return i; return -1; }  data[0] ~ data[n-1] target을 검색하는 것 검색 구간의 시작 인덱스 0은 보통 생략합니다.</description>
    </item>
    
    <item>
      <title>Hugo로 개인 블로그 만들기 &#43; git submodule</title>
      <link>https://mj-seok.com/tech/git-submodule/</link>
      <pubDate>Mon, 30 Dec 2019 22:37:32 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/git-submodule/</guid>
      <description>Hugo로 개인 블로그 만들기 + git submodule  https://gohugo.io/
  Hugo는 &amp;ldquo;웹사이트를 만드는데 세계에서 가장 빠른 프레임워크&amp;quot;라고 단언하는
오픈소스 기반 정적 사이트(static site) 제작 툴입니다.   Hugo 설치 (Install Hugo) git Command Hugo Post  1. Hugo 설치 (Install Hugo)  https://gohugo.io/getting-started/quick-start/
 MacOS 기준 (for MacOS)
Hugo 설치 (Install Hugo) brew install hugo Hugo 버전 확인 (check Hugo&amp;rsquo;s version) hugo version Hugo 사이트 만들기 (Create a new Hugo site) hugo new site quickstart Hugo 테마 추가하기 (Add a Theme) cd quickstart git init git submodule add https://github.</description>
    </item>
    
    <item>
      <title>고로 작성해봐요 - Write in Go</title>
      <link>https://mj-seok.com/tech/go-first/</link>
      <pubDate>Mon, 30 Dec 2019 22:27:58 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/go-first/</guid>
      <description>고로 작성해봐요 - Write in Go 안녕, 고 (Hello, Go) package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, Go&amp;#34;) } Go 언어 설치 (Install Go Language) https://golang.org/
Go 설치 후 go tour 시작 코드 (After installing, go tour code) % go get code.google.com/p/go-tour/gotour 패키지 (Packages) package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) func main() { fmt.Println(&amp;#34;My favorite number is&amp;#34;, rand.Intn(10)) }  모든 Go 프로그램은 패키지로 구성 (Every Go Program is made up of packages) import () 형태로 패키지를 불러옵니다.</description>
    </item>
    
    <item>
      <title>PostgreSQL - 명령어 정리(Command)</title>
      <link>https://mj-seok.com/database/sql-postgresql/</link>
      <pubDate>Thu, 26 Dec 2019 21:52:28 +0900</pubDate>
      
      <guid>https://mj-seok.com/database/sql-postgresql/</guid>
      <description>PostgreSQL - 명령어 정리(Command) Install on Mac https://formulae.brew.sh/formula/postgresql
install Command brew install postgresql Server start pg_ctl -D /usr/local/var/postgres start Server stop pg_ctl -D /usr/local/var/postgres stop status check export PGDATA=&amp;#39;/usr/local/var/postgres&amp;#39; pg_ctl status  </description>
    </item>
    
    <item>
      <title>Python 가상환경 - pyenv 설치</title>
      <link>https://mj-seok.com/tech/python-pyenv/</link>
      <pubDate>Mon, 23 Dec 2019 21:24:34 +0900</pubDate>
      
      <guid>https://mj-seok.com/tech/python-pyenv/</guid>
      <description>Python 가상환경 - pyenv 설치  mac 기준, Homebrew를 사용해서 설치합니다.
 설치 % brew update % brew install pyenv 환경설정 % echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc % echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc % echo -e &amp;#39;if command -v pyenv 1&amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then\n eval &amp;#34;$(pyenv init -)&amp;#34;\nfi&amp;#39; &amp;gt;&amp;gt; ~/.zshrc Python 원하는 버전 설치 % pyenv install [version_name] % pyenv global [version_name] % python --version   행복 개발
 </description>
    </item>
    
    <item>
      <title>재귀적 생각 - Recursive Thinking</title>
      <link>https://mj-seok.com/algorithm/algo-recursive/</link>
      <pubDate>Sun, 22 Dec 2019 23:50:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/algorithm/algo-recursive/</guid>
      <description>재귀적 생각 - Recursive Thinking [ Reference ] : https://youtu.be/tuzf1yLPgRI
절차적 언어 ? Procedure Language : 어떤 일을 하는 절차
프로그래밍에서의 관점  객체 지향 : 객체들 간의 상호작용 Recursion : 순환적인 관점  Recursion은 수학함수 계산에만 유용한가  수학함수뿐 아니라 다른 많은 문제들을 recursion으로 해결할 수 있습니다.  문자열의 길이 계산 :: pesudo code
if the string is empty return 0; else return 1 plus the length of the string that excludes the first character;  순환적인 문자열 길이 계산 알고리즘  :: length.</description>
    </item>
    
    <item>
      <title>DB 정규화 - Database Normalization</title>
      <link>https://mj-seok.com/database/sql-db-normalization/</link>
      <pubDate>Thu, 19 Dec 2019 21:10:08 +0900</pubDate>
      
      <guid>https://mj-seok.com/database/sql-db-normalization/</guid>
      <description>DB 정규화 - Database Normalization [Reference] : https://mangkyu.tistory.com/28
제1정규형 - 원자값 제2정규형 - 기본키에 완전 함수 종속 제3정규형 - 기본키가 아닌 속성이 기본키에 비이행적으로 종속(직접 종속) 제4정규형 - BCNF (함수 종속성 X-&amp;gt;Y 성립할 때 모든 결정자 X가 후보키인 정규형 이상 현상을 없애려면 함수 종속성   행복 코딩
 </description>
    </item>
    
    <item>
      <title>타입스크립트 기초 - TypeScript Basic</title>
      <link>https://mj-seok.com/javascript/typescript/</link>
      <pubDate>Wed, 18 Dec 2019 21:34:00 +0900</pubDate>
      
      <guid>https://mj-seok.com/javascript/typescript/</guid>
      <description>타입스크립트 기초 - TypeScript Basic [Reference] : https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
Install npm install -g typescript  node.js가 설치되어 있는 환경에서 typescript를 npm 패키지 매니저로 전역(-g) 설치합니다.  Compile tsc helloworld.ts  컴파일 명령어는 tsc 입니다.  greeter.ts function greeter(person) { return &amp;#34;Hello, &amp;#34; + person; } let user = &amp;#34;Jane User&amp;#34;; // document.body.textContext = greeter(user); console.log(greeter(user));  가장 기본적인 방법으로 함수에 인자 넣어 콘솔에 로그를 찍습니다.  터미널 환경에서 &amp;ldquo;tsc greeter.ts&amp;rdquo;, &amp;ldquo;node greeter.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://mj-seok.com/about/</link>
      <pubDate>Wed, 18 Dec 2019 21:33:23 +0900</pubDate>
      
      <guid>https://mj-seok.com/about/</guid>
      <description>const Introduce = () =&amp;gt; { return { name: &amp;#34;Jose Seok&amp;#34;, job: &amp;#34;Front-end Developer&amp;#34;, focus: [&amp;#34;ECMAScript&amp;#34;, &amp;#34;React.js&amp;#34;, &amp;#34;Node.js&amp;#34;, &amp;#34;Algorithm&amp;#34;] }; }   행복 프로그래밍
 </description>
    </item>
    
  </channel>
</rss>