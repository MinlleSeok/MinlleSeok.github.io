<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Happiness Development</title>
    <link>https://mj-seok.com/</link>
    <description>Recent content on Happiness Development</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Feb 2020 13:59:28 +0900</lastBuildDate>
    
	<atom:link href="https://mj-seok.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MST 알고리즘 - Prim의 알고리즘</title>
      <link>https://mj-seok.com/posts/algo-prim/</link>
      <pubDate>Mon, 24 Feb 2020 13:59:28 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-prim/</guid>
      <description>MST 알고리즘 - Prim의 알고리즘  임의의 노드를 출발노드로 선택 출발 노드를 포함하는 트리를 점점 키워 감. 매 단계에서 이미 트리에 포함된 노드와 포함되지 않은 노드를 연결하는 에지들 중 가장 가중치가 작은 에지를 선택   A = zero safe |A| = n - 1
 왜 MST가 찾아지는가?  Prim의 알고리즘의 임의의 한 단계를 생각해보자. A를 현재까지 알고리즘이 선택한 에지의 집합이라고 하고, A를 포함하는 MST가 존재한다고 가정하자. 출발 노드에 이미 연결된 노드와 그렇지 않은 노드를 연결하는 에지들 중 lightest edge  가중치가 최소인 에지 찾기  V(A) : 이미 트리에 포함된 노드들 V(A) 에 아직 속하지 않은 각 노드 v에 대해서 다음과 같은 값을 유지  key(v) : 이미 V(A) 에 속한 노드와 자신을 연결하는 에지들 중 가중치가 최소인 에지 (u, v)의 가중치 ㅠ(v) : 그 에지 (u, v)의 끝점 u   가중치가 최소인 에지를 찾는 대신 key값이 최소인 노드를 찾습니다.</description>
    </item>
    
    <item>
      <title>Elastic Search</title>
      <link>https://mj-seok.com/posts/es-1/</link>
      <pubDate>Wed, 19 Feb 2020 13:48:33 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/es-1/</guid>
      <description>Elastic Search  검색 및 분석 엔진 Logstash 와 Beats가 데이터 수집, 통합, 저장 Kibana 데이터 탐색, 시각화, 영감 공유 및 스택 모니터링 인덱싱, 검색, 분석을 강점으로 합니다.  데이터  문서 저장소입니다. 컬럼 로우로 저장하지 않고, JSON 문서로 시리얼라이즈해서 저장합니다. inverted index 자료 구조를 사용하여 거의 1초이내에 검색합니다.   </description>
    </item>
    
    <item>
      <title>Java Programming Language</title>
      <link>https://mj-seok.com/posts/java-1/</link>
      <pubDate>Wed, 19 Feb 2020 13:10:18 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/java-1/</guid>
      <description>Java Programming Language  특징  고수준 언어 간결합니다. 아키텍처 중립 객체 지향 멀티쓰레드    Software Development Process MyProgram.java - compiler -&amp;gt; MyProgram.class - Java VM -&amp;gt; My Program
 가상 머신 덕분에 다양한 플랫폼에서 동작 가능합니다. JAVA Application Programming Interface (API) Java Virtual Machine   플랫폼 독립전인 만큼 네이티브 코드보단 느릴 수 있지만 최근 기술 개선을 많이 이루어서 거의 비슷한 성능까지 끌어올렸다고 합니다.
 Java로 할 수 있는 것  개발 툴 : 컴파일, 러닝, 모니터링, 디버깅, 문서화 API : 애플리케이션에 사용할 수 있도록 만들어진 핵심 기능 및 유용한 클래스들 배포 기술 : 표준 구조 제공 유저 인터페이스 툴킷 : JavaFX, Swing등 통합 라이브러리 : 대표적으로 DB연결 라이브러리 등  Java가 돕는 것  쉽게 시작하게 합니다 적은 코드를 쓰게 합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 기초 정리</title>
      <link>https://mj-seok.com/posts/algo-1/</link>
      <pubDate>Mon, 17 Feb 2020 11:49:56 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-1/</guid>
      <description>알고리즘 - 기초 정리  주어진 문제를 명확히 하는 것! 모든 경우의 수를 다 순차 검색하는 것이 기장 기본적이라고 생각할 수 있습니다.  정렬이 된 경우라면?  오름차순, 내림차순으로 정렬을 합니다.  const BinarySearch = 그리디(탐욕) 알고리즘 const GreedySearch = function (changes, won) { for (let i = 0; i &amp;lt; changes.length; i++) { } } 오울러 트레일  아무거나 먼저 시작하기 미리 보기 전략  const EulerTrail = if cycle 미로 찾기  백트래킹 오일러 서킷  가짜 코인  어떤 코인이 함량이 낮은가?</description>
    </item>
    
    <item>
      <title>컴퓨터 과학 - Computer Science</title>
      <link>https://mj-seok.com/posts/cs-1/</link>
      <pubDate>Sat, 15 Feb 2020 18:40:43 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/cs-1/</guid>
      <description>컴퓨터 과학 - Computer Science  2500년 전 주판 : 계산의 상태 기록 1600년 대 : 컴퓨터 직업에 대한 표현 1800년 대 : 컴퓨터 기계로 표현  계전기  릴레이, 수도꼭지같이 열었다 닫았다 합니다. 컴퓨터 버그 - 진기 기계씩 릴레이 기계에 붙어있는 벌레  열 이온 밸브(진공관)  다이오드 : 한쪽으로 호르는 전기 전자 기계식 컴퓨팅 -&amp;gt; 전자 컴퓨팅 ENIAC : 전자 컴퓨터 시작 트랜지스터 : 전류를 흐르게 하거나 멈추게 합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 최소비용 신장 트리(MST)</title>
      <link>https://mj-seok.com/posts/algo-mst/</link>
      <pubDate>Sat, 15 Feb 2020 16:44:18 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-mst/</guid>
      <description>알고리즘 - 최소비용 신장 트리(MST)  입력 : n개의 도시, 도시와 도시를 연결하는 비용 문제 : 최소의 비용으로 모든 도시들이 서로 연결되게 합니다.  최소비용 신장 트리 (Minimum Spanning Tree)  해가 유일하지는 않음 무방향 가중치 그래프 G=(V,E) 각 에지 (u, v) &amp;lt; E 에 대해서 가중치 w(u, v) 문제 : 다음과 같은 조건을 만족하는 에지들의 부분집합 T &amp;lt; E 를 찾자.    T에 속한 에지들에 의해 그래프의 모든 정점들이 서로 연결됩니다.</description>
    </item>
    
    <item>
      <title>Webpack 개념</title>
      <link>https://mj-seok.com/posts/webpack-intro/</link>
      <pubDate>Fri, 14 Feb 2020 17:13:46 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/webpack-intro/</guid>
      <description>[Reference] : https://webpack.js.org/concepts/
Webpack 개념  모던 자바스크립트 애플리케이션을 위한 정적 모듈 번들러  핵심 개념  Entry (시작점) Output (출력) Loaders (로더) Plugins (플러그인) Mode (모드) Browser Compatibility (브라우저 호환성)  Entry  entry point : 내부 의존성 그래프가 빌드하기 시작하는 지점을 표기   webpack.config.js
 module.exports = { entry: &amp;#39;./path/to/my/entry/file.js&amp;#39; }; Output  output : 번들된 곳을 방출하는 위치   webpack.config.js
 const path = require(&amp;#39;path&amp;#39;); module.</description>
    </item>
    
    <item>
      <title>DAG(Directed Acyclic Graph)</title>
      <link>https://mj-seok.com/posts/algo-dag/</link>
      <pubDate>Fri, 14 Feb 2020 16:15:40 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-dag/</guid>
      <description>DAG(Directed Acyclic Graph)  방향 사이클(directed cycle)이 없는 방향 그래프. 예: 작업들의 우선순위  위상정렬(topological ordering)  DAG에서 노드들의 순서화 v(1), v(2), v(3), &amp;hellip; v(n), 단, 모든 에지(v(i), v(j))에 대해서 i &amp;lt; j가 되도록. 일반적으로 답이 유일하지 않습니다.  위상정렬 알고리즘 1   들어오는 edge : incoming edge
  그 갯수 : indegree
  나가는 edge : outgoing edge
  그 갯수 : outdegree
   indegree가 0인 노드를 찾습니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 깊이우선순회(DFS)</title>
      <link>https://mj-seok.com/posts/algo-dfs/</link>
      <pubDate>Tue, 11 Feb 2020 12:02:13 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-dfs/</guid>
      <description>알고리즘 - 깊이우선순회(DFS)  이진트리 순회 방법  in-order(dfs) pre-order(dfs) post-order(dfs) level-order(bfs)     출발점 s에서 시작합니다.    현재 노드를 visited로 mark하고 인접한 노드들 중 unvisited 노드가 존재하면 그 노드로 갑니다.    2번을 계속 반복합니다.    만약 unvisited인 이웃 노드가 존재하지 않는 동안 계속해서 직전 노드로 되돌아갑니다.    다시 2번을 반복합니다.    시작노드 s로 돌아오고 더 이상 갈 곳이 없으면 종료합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 그래프 순회 (Graph Traversal)</title>
      <link>https://mj-seok.com/posts/algo-bfs/</link>
      <pubDate>Tue, 11 Feb 2020 11:57:36 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-bfs/</guid>
      <description>알고리즘 - 그래프 순회 (Graph Traversal)  순회(traversal) 그래프의 모든 노드들을 방문하는 일 대표적 두 가지 방법 BFS (Breadth-First Search, 너비우선순회) DFS (Depth-First Search, 깊이우선순회)  너비우선순회 (BFS)  BFS 알고리즘은 다음 순서로 노드들을 방문 L(0) = {s}, 여기서 s는 출발 노드 L(1) = L(0)의 모든 이웃 노드들 L(2) = L(1)의 이웃들 중 L(0)에 속하지 않은 노드들 &amp;hellip; L(i) = L(i - 1)의 이웃들 중 L(i - 2)에 속하지 않는 노드들 동심원 형태  큐를 이용한 너비우선순회  s = 1 체크는 이미 방문된 노드라는 표시   check the start node;    insert the start node into the queue;    while the queue is not empty do remove a node v from queue; for each unchecked neighbour w of v do check and insert w into the queue; 너비우선순회 BFS(G, s)	// 그래프 G와 출발 노드 s Q &amp;lt;- empty queue; Enqueue(Q, s); while Q =/ empty do u &amp;lt;- Dequeue(Q) for each v adjacent to u do if v is unvisited then mark v as visited; Enqueue(Q, v); end.</description>
    </item>
    
    <item>
      <title>Algo Graph</title>
      <link>https://mj-seok.com/posts/algo-graph/</link>
      <pubDate>Sun, 09 Feb 2020 15:01:49 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-graph/</guid>
      <description>알고리즘 - 그래프 알고리즘  개념과 표현  그래프 (Graph)  (무방향) 그래프 G = (V, E) // 두 개의 집합에 의해서 정의되는 구조 V : 노드(node) 혹은 정점(vertex) // 정점의 집합 E : 노드쌍을 연결하는 에지(edge) 혹은 링크(link) // 정점과 정점을 연결하는 에지들의 집합 개체(object)들 간의 이진관계를 표현 n = |V|, m = |E|  V = {1, 2, 3, 4, 5, 6, 7, 8} E = {(1, 2), (1, 3), (2, 3), &amp;hellip;, (7, 8)} n = 8 (정점의 개수) m = 11 (에지의 개수)    방향 그래프와 가중치 그래프  방향그래프(Directed Graph) G = (V, E)  에지 (u, v)는 u로부터 v로의 방향을 가짐   가중치(weighted) 그래프  에지마다 가중치(weight)가 지정    다중 엣지 와 셀프 엣지  다중 엣지 : 엣지 집합, 집합이기 때문에 중복 값이 들어가면 안 됩니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 해싱</title>
      <link>https://mj-seok.com/posts/algo-hashing/</link>
      <pubDate>Wed, 05 Feb 2020 11:09:52 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-hashing/</guid>
      <description>알고리즘 - 해싱 Hashing  해쉬 테이블은 dynamic set을 구현하는 효과적인 방법의 하나 적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O(1) 보통 최악의 경우 O(n)  Hash Table  해쉬 함수(hash function) h를 사용하여 키 k를 T[h(k)]에 저장  h : U -&amp;gt; {0, 1, &amp;hellip;, m - 1}, U : 양의 정수들의 집합 여기서 m은 테이블의 크기, U는 모든 가능한 키들의 집합   키 k가 h(k)로 해슁되었다고 말함. 해쉬테이블은 일반적으로 하나의 배열 즉 각 키에 대한 해쉬함수값을 그 키를 저장할 배열 인덱스로 사용  index = h(k: a key) h(X) = x % m 0 .</description>
    </item>
    
    <item>
      <title>알고리즘 - 레드 블랙 트리</title>
      <link>https://mj-seok.com/posts/algo-rb/</link>
      <pubDate>Tue, 04 Feb 2020 12:06:23 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-rb/</guid>
      <description>알고리즘 - 레드 블랙 트리  이진탐색트리의 일종 균형잡힌 트리 : 높이가 O(log(2)n) SEARCH, INSERT, DELETE 연산을 최악의 경우에도 O(log(2)n) 시간에 지원  레드-블랙 트리  각 노드는 하나의 키(key), 왼쪽자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장 자식노드가 존재하지 않을 경우 NIL 노드라고 부르는 특수한 노드가 있다고 가정 따라서 모든 리프노드는 NIL노드 루트의 부모도 NIL노드라고 가정 노드들은 내부노드와 NIL노드로 분류  레드-블랙 트리: 정의  다음의 조건을 만족하는 이진탐색트리 : 각 노드는 red 혹은 black이고, 루트노드는 black이고, 모든 리프노드(즉, NIL노드)는 black이고, red노드의 자식들은 전부 black이고(즉, red노드는 연속되어 등장하지 않고), 모든 노드에 대해서 그 노드로부터 자손인 리프노드에 이르는 모든 경로에는 동일한 개수의 black노드가 존재합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 이진검색트리(Binary Search Tree)</title>
      <link>https://mj-seok.com/posts/algo-binary-search-tree/</link>
      <pubDate>Thu, 30 Jan 2020 12:48:31 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-binary-search-tree/</guid>
      <description>알고리즘 - 이진검색트리(Binary Search Tree)  이진트리 순회하는 알고리즘 트리라는 자료구조 조직도, 가계도  Dynamic Set  저장하는 데이터 자체가 계층 구조가 아닌 일종의 컨테이너(집합) 여러 개의 키(key)를 저장 다음과 같은 연산들을 지원하는 자료구조 INSERT - 새로운 키의 삽입 SEARCH - 키 탐색 DELETE - 키의 삭제 예 : 심볼 테이블 called Dynamic Set Dictionary Search Structure  시간 복잡도  정렬 안 된 배열 검색 : 순차검색 O(n) 정렬 안 된 배열 삽입 : 맨 뒤 O(1) 배열 복사 이동 고려 O(n) 정렬 안 된 배열 삭제 : 검색 고려하지 않고 마지막 데이터와 교체 O(1) 정렬된 배열 검색 : 이진검색 O(logn) 정렬된 배열 삽입 : 다른 값 위치 shift O(n) 정렬된 배열 삭제 : 다른 값 위치 shift O(n) 정렬 안 된 연결 리스트 검색 : O(n) 정렬 안 된 연결 리스트 삽입 : 맨 앞 O(1) 정렬 안 된 연결 리스트 삭제 : 검색 고려하지 않고 마지막 데이터와 교체 O(1) 정렬된 연결 리스트 검색 : n / 2 바로 탐색 불가 O(n) 정렬된 연결 리스트 삽입 : O(n) 정렬된 연결 리스트 삭제 : O(1)  다양한 방법들  정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n) 이진탐색트리(Binary Search Tree), 레드-블랙 트리, AVL-트리 등의 트리에 기반한 구조들 Direct Address Table, 해쉬 테이블 등  검색트리  Dynamic set을 트리의 형태로 구현 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 가짐 이진검색트리(Binary Search Tree), 레드-블랙 트리(red-black tree), B-트리 등  이진검색트리 (BST)  이진 트리이면서 각 노드에 하나의 키를 저장 각 노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같습니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - 트리와 이진트리</title>
      <link>https://mj-seok.com/posts/algo-tree/</link>
      <pubDate>Thu, 30 Jan 2020 11:45:59 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-tree/</guid>
      <description>알고리즘 - 트리와 이진트리  계층적인 구조를 표현 조직도 디렉토리와 서브디렉토리 구조 가계도  맨 위의 노드 : 루트(root)  트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성됨 노드들을 연결하는 선을 &amp;ldquo;link&amp;rdquo;, &amp;ldquo;edge&amp;rdquo;, &amp;ldquo;branch&amp;quot;등으로 부름  부모-자식 관계  부모(parent) 노드 : animal 자식(child) 노드 : cat, fox, wolf  형제 관계  루트노드를 제외한 트리의 모든 노드들은 유일한 부모 노드를 가짐 부모가 동일한 노드들을 형제(sibling) 관계라고 부름  리프(leaf) 노드  리프노드가 아닌 노드들을 내부(internal)노드라고 부름 자식이 없는 노드들을 leaf노드라고 부름  조상 - 자손 관계  조상(ancestor) 노드 : animal 자손(descendant) 노드 : canine 부모 - 자식 관계를 확장한 것이 조상 - 자손 (ancestor - descendant) 관계입니다.</description>
    </item>
    
    <item>
      <title>[알고리즘] Java에서의 정렬</title>
      <link>https://mj-seok.com/posts/algo-java-sort/</link>
      <pubDate>Wed, 29 Jan 2020 12:26:07 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-java-sort/</guid>
      <description>[알고리즘] Java에서의 정렬  Arrays클래스가 primitive타입 데이터를 위한 정렬 메서드를 제공  int[] data = new int[capacity]; // data[0]에서 data[capacity - 1]까지 데이터가 꽉 // 차있는 경우에는 다음과 같이 정렬합니다. Arrays.sort(data); // 배열에 꽉 차있지 않고 data[0]에서 data[size - 1]까지 // size개의 데이터만 있다면 다음과 같이 합니다. Arrays.sort(data, 0, size);  int 이외의 다른 primitive 타입 데이터(double, char 등)에 대해서도 제공  객체의 정렬 : 문자열 String [] fruits = new String[] { &amp;#34;Pineapple&amp;#34;, &amp;#34;Apple&amp;#34;, &amp;#34;Orange&amp;#34;, &amp;#34;Banana&amp;#34; }; Arrays.</description>
    </item>
    
    <item>
      <title>알고리즘 - Radix Sort</title>
      <link>https://mj-seok.com/posts/algo-radix-sort/</link>
      <pubDate>Wed, 29 Jan 2020 12:02:51 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-radix-sort/</guid>
      <description>Radix Sort  n개의 d자리 정수들 가장 낮은 자리수부터 정렬  Stable Sort  동일한 데이터가 2개 이상 있다면 정렬 후에도 입력 순서가 출력 순서로 유지되야 합니다. Radix Sort 같은 경우는 반드시 Stable 해야 합니다.  RADIX-SORT(A, d) for i &amp;lt;- 1 to d do use a stable sort to sort array A on digit i  시간 복잡도 O(d(n+k)) 10진수 (k = 10) 알파벳 (k = 26)  정렬 알고리즘들  Bubble sort : O(n^2) Insertion sort : O(n^2) Selection sort : O(n^2) Quick Sort : worst O(n^2) and average O(nlog2n) Merge sort : O(nlog2n) Heap sort : O(nlog2n) Counting sort : O(n+k) Radix sort : O(d(n+k))  </description>
    </item>
    
    <item>
      <title>알고리즘 - 선형 시간 정렬</title>
      <link>https://mj-seok.com/posts/algo-sorting-linear/</link>
      <pubDate>Wed, 29 Jan 2020 10:44:39 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-sorting-linear/</guid>
      <description>선형 시간 정렬 Counting Sort  n개의 정수를 정렬하세요. 단 모든 정수는 0에서 k 사이의 정수입니다. 길이 k인 배열에 각 정수의 개수를 count합니다.  int A[n]; // 정렬할 데이터 0 ~ k int C[k] = {0, }; for ( int i=1; i&amp;lt;=n; i++ ) C[A[i]]++; for ( int s=1, i=0; i&amp;lt;=k; i++ ) { for ( int j=0; j&amp;lt;C[i]; j++ ) { A[s++] = i; } } COUNTING-SORT(A, B, k) for i &amp;lt;- 0 to k do C[i] &amp;lt;- 0 for j &amp;lt;- 1 to length[A] do C[A[j]] &amp;lt;- C[A[j]] + 1 &amp;gt; C[i] now contains the number of elements equal to i.</description>
    </item>
    
    <item>
      <title>Spring boot와 React.js의 만남 - 프론트엔드</title>
      <link>https://mj-seok.com/posts/spring-react-2/</link>
      <pubDate>Thu, 23 Jan 2020 10:28:36 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/spring-react-2/</guid>
      <description>Spring boot(백엔드)와 React.js(프론트엔드)의 만남 - 프론트엔드 1단계 UI Controller를 만들어봅시다.(Spring MVC Controller) package com.mjseok.springreact; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HomeController { @RequestMapping(value = &amp;#34;/&amp;#34;) public String index() { return &amp;#34;index&amp;#34;; } }  @Controller : Spring MVC Controller인 class에 마크합니다. @RequestMapping : index() 메소드에 / route를 도와줍니다. &amp;quot;index&amp;quot; template return =&amp;gt; 뷰 리졸버가 src/main/resources/templates/index.html 를 매핑합니다.  2단계 HTML 템플릿 만들기  src/main/resources/templates/index.html
 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html xmlns:th=&amp;#34;https://www.thymeleaf.org&amp;#34;&amp;gt; &amp;lt;head lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;/&amp;gt; &amp;lt;title&amp;gt;ReactJS + Spring Data REST&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/main.</description>
    </item>
    
    <item>
      <title>탐욕 알고리즘 - Greedy Algorithm</title>
      <link>https://mj-seok.com/posts/algo-greedy/</link>
      <pubDate>Wed, 22 Jan 2020 22:39:30 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-greedy/</guid>
      <description>탐욕 알고리즘 - Greedy Algorithm  현재 상황에서 가장 좋아 보이는 답을 선택하는 방법 각 부분에서 최적을 선택하면 전체에서도 최적이 될 것이라는 가정을 전제로 합니다. 선택은 항상 하위 문제에 대한 해답이 나오기 전에 선택됩니다.  탐욕 선택  하위 문제를 풀기 전에 선택을 합니다. 항상 하나의 문제만을 고려합니다.  동적 프로그래밍  하위 문제를 풀고 나서 선택을 합니다. 동시에 여러 개의 하위 문제를 고려합니다.  0-1 배낭 채우기 문제 (0-1 knapsack)  도둑이 상점에서 n개의 물건을 훔친다고 합니다.</description>
    </item>
    
    <item>
      <title>Spring boot와 React.js의 만남 - 백엔드</title>
      <link>https://mj-seok.com/posts/spring-react/</link>
      <pubDate>Wed, 22 Jan 2020 18:06:35 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/spring-react/</guid>
      <description>Spring boot(백엔드)와 React.js(프론트엔드)의 만남 [ Reference ] : https://spring.io/guides/tutorials/react-and-spring-data-rest/
[ Spring Initializr ] : https://start.spring.io/
1단계 Spring Initializr 아래의 Dependencies 를 추가해서 Generate 합니다.
 Rest Repositories Thymeleaf JPA H2  만들어진 스프링 프로젝트를 압축해제 합니다.
2단계 첫 java 파일 IDE로 스프링프로젝트를 엽니다.
 Spring Data REST 를 사용하므로 간편하게 작업할 수 있습니다.  domain 선언  Employee.java
 package com.mjseok.springreact; import java.util.Objects; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Employee { private @Id @GeneratedValue Long id; private String firstName; private String lastName; private String description; private Employee() {} public Employee(String firstName, String lastName, String description) { this.</description>
    </item>
    
    <item>
      <title>정렬 알고리즘 - Sort Algorithm</title>
      <link>https://mj-seok.com/posts/algo-sort/</link>
      <pubDate>Tue, 14 Jan 2020 11:13:38 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-sort/</guid>
      <description>정렬 알고리즘 - Sort Algorithm [ Reference ] : https://youtu.be/0dG7xTt5IfQ
 정렬이 가장 기본입니다.  간단하고, 느린 정렬 - Simple, Slow  Bubble sort Insertion sort Selection sort  빠른 정렬 - Fast  Quick sort Merge sort Heap sort  O(N) 근본적으로 다른 알고리즘  Radix sort  기본적인 정렬 알고리즘 선택 정렬 - Selection Sort  initial array = [29, 10, 14, 37, 13]; 가장 큰 값을 맨 마지막 값과 바꿉니다.</description>
    </item>
    
    <item>
      <title>정렬 알고리즘 2 - Sort Algorithm</title>
      <link>https://mj-seok.com/posts/algo-sort-2/</link>
      <pubDate>Tue, 14 Jan 2020 11:13:38 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-sort-2/</guid>
      <description>정렬 알고리즘 - Sort Algorithm [ Reference ] : https://youtu.be/0dG7xTt5IfQ
 정렬이 가장 기본입니다.  간단하고, 느린 정렬 - Simple, Slow  Bubble sort Insertion sort Selection sort  빠른 정렬 - Fast  Quick sort Merge sort Heap sort  O(N) 근본적으로 다른 알고리즘  Radix sort  힙 정렬 - Heap Sort  힙, 바이너리 힙 이진 힙 자료구조 정렬 최악의 경우 시간복잡도 O(nlog(2)n) Sorts in place - 추가 배열 불필요 이진 힙(binary heap) 자료구조를 사용  Heap의 정의  complete binary tree이면서, heap property 만족  Full vs Complete Binary Trees   full binary tree: 모든 레벨에 노드들이 꽉 차있는 형태</description>
    </item>
    
    <item>
      <title>알고리즘의 기본 - Algorithm Basic</title>
      <link>https://mj-seok.com/posts/algorithm-desc/</link>
      <pubDate>Sun, 12 Jan 2020 13:44:48 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algorithm-desc/</guid>
      <description>알고리즘의 기본 - Algorithm Basic [ Reference ] : https://www.youtube.com/watch?v=qQ5iLNjpxSk&amp;amp;list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz
알고리즘이란 &amp;lsquo;문제를 해결하는 절차&#39;입니다  입력, 출력, 유한성, 명백성, 효과성을 만족해야 합니다. 분석을 통해 좋고 나쁨을 평가할 수 있습니다. 기초 프로그래밍과 자료구조를 공부한 이후에 배우면 좋습니다. 논리이며 수학이고, 실질적인 개발에 적용되는 기초적인 아이디어입니다.   점근적 분석법, 행렬? 버블정렬, 선택정렬 보다 퀵 정렬이 빠르게 수행됩니다.
 알고리즘은 &amp;lsquo;개발&#39;의 전체 과정에 사용됩니다  실제 프로그램을 개발할 때 효율적인 알고리즘을 적용함으로써 원하는 결과를 도출해야 합니다.</description>
    </item>
    
    <item>
      <title>알고리즘 - N-Queens Problem</title>
      <link>https://mj-seok.com/posts/algo-nqueens/</link>
      <pubDate>Sat, 11 Jan 2020 14:24:45 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-nqueens/</guid>
      <description>알고리즘 - N-Queens Problem  N x N 체스 보드 N = 8 동일한 행, 동일한 대각선, 동일한 열 빼놓고 말을 놓는 방법  4 x 4  하나의 행마다 정확히 하나의 말 서로 다른 경우의 수 : N의 N승 Backtracking : 최근에 내렸던 결정을 번복하고, 지나온 궤적을 되돌아 나간다.  상태 공간 트리  상태공간트리 : 찾는 해를 포함하는 트리. 즉, 해가 존재한다면 그것은 반드시 이 트리의 어떤 한 노드에 해당함 따라서 이 트리를 체계적으로 탐색하면 해를 구할 수 있음  상태 공간 트리의 모든 노드를 탐색해야 하는 것은 아님  (1,1) (2,1) -&amp;gt; non-promising (1,1) (2,2) -&amp;gt; infeasible: 꽝 (1,1) (2,3) -&amp;gt; continue&amp;hellip;  되추적 기법(Backtracking)  상태공간 트리를 깊이 우선 방식으로 탐색하여 해를 찾는 알고리즘  깊이 우선 탐색  recursion stack 자료구조 이용  Design Recursion // 매개변수는 내가 현재 트리의 어떤 노드에 있는지를 지정해야 한다.</description>
    </item>
    
    <item>
      <title>블롭 셀 카운팅 알고리즘 - Counting Cells in a Blob</title>
      <link>https://mj-seok.com/posts/algo-countcell/</link>
      <pubDate>Sat, 11 Jan 2020 13:42:06 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-countcell/</guid>
      <description>블롭 셀 카운팅 알고리즘 - Counting Cells in a Blob [ Reference ] : https://youtu.be/HHJFlVT1tBw
 Binary 이미지 각 픽셀은 background pixel이거나 image pixel Blob - 서로 연결된 image pixel들의 집합을 blob이라고 부름 상하좌우 및 대각방향으로도 연결된 것으로 간주  입력 :
 N x N 크기의 2차원 그리드(grid) 하나의 좌표 (x, y)  출력 :
 픽셀 (x, y)가 포함된 blob의 크기 (x, y)가 어떤 blob에도 속하지 않는 경우에는 0  Recursive Thinking 현재 픽셀이 이 속한 blob의 크기를 카운트하려면 현재 픽셀이 image color가 아니라면 // base case 0을 반환한다 현재 픽셀이 image color라면 먼저 현재 픽셀을 카운트한다 (count=1) 현재 픽셀이 중복 카운트되는 것을 방지하기 위해 다른 색으로 칠한다.</description>
    </item>
    
    <item>
      <title>미로찾기 알고리즘 - Maze Algorithm</title>
      <link>https://mj-seok.com/posts/algo-maze/</link>
      <pubDate>Fri, 10 Jan 2020 22:06:14 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-maze/</guid>
      <description>미로찾기 알고리즘 - Maze Algorithm Recursive Thinking
현재 위치에서 출구까지 가는 경로가 있으려면
 현재 위치가 출구이거나 혹은 이웃한 셀들 중 하나에서 현재 위치를 지나지 않고 출구까지 가능 경로가 있거나  aa
미로찾기(Decision Problem - return yes or no) boolean findPath(x, y) if (x, y) is the exit return true; else for each neighbouring cell (x`, y`) of (x, y) do if (x`, y`) is on the pathway if findPath(x`, y`) return true; return false;  인접한 셀이 초기값과 무한 루프에 빠질 수 있습니다.</description>
    </item>
    
    <item>
      <title>ES6 - 적절한 꼬리 호출(Proper Tail Calls)</title>
      <link>https://mj-seok.com/posts/ecma-ptc/</link>
      <pubDate>Wed, 08 Jan 2020 18:46:45 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/ecma-ptc/</guid>
      <description>ECMAScript 6 - 적절한 꼬리 호출(Proper Tail Calls) https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/
적절한 꼬리 호출?(Proper Tail Calls)  Proper Tail Calls(PTC)는 ECMAScript 6 언어의 새로운 특징입니다. recursive 프로그래밍 패턴을 수월하게 하고자 추가됬다고 합니다. stack overflow exception 를 발생시키는 코드도 실행할 수 있게 한다고 합니다.  부연 설명  일반적으로 함수 호출할 때, 함수 호출과 관련된 데이터에 스택 공간을 할당합니다. 이 데이터에는 반환 주소, 이전 스택 포인터, 함수에 대한 전달인자, 로컬 값에 대한 공간(스택 프레임)등 있습니다.</description>
    </item>
    
    <item>
      <title>Javascript와 ECMAScript - 알아보기</title>
      <link>https://mj-seok.com/posts/ecma-javascript/</link>
      <pubDate>Mon, 06 Jan 2020 23:50:45 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/ecma-javascript/</guid>
      <description>Javascript와 ECMAScript - 알아보기 ECMAScript 와 JavaScript JavaScript https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript
 복잡한 무언가(주기적으로 내용이 갱신되는 기능이나 능동적인 지도, 변화하는 2D/3D 그래픽, 동영상 등)를 웹페이지에 적용할 수 있게 하는 스크립트 혹은 프로그래밍 언어입니다.  기본 작성 형태 // HTML 요소 중 p태그를 선택 const para = document.querySelector(&amp;#39;p&amp;#39;); para.addEventListener(&amp;#39;click&amp;#39;, updateName); function updateName() { //&amp;#39;Enter a new name&amp;#39;과 입력란 출력하여 입력받은 값을 name에 저장  let name = prompt(&amp;#39;Enter a new name&amp;#39;); // para(p태그)에 새로운 문자열 저장  para.</description>
    </item>
    
    <item>
      <title>Python - for in 문법</title>
      <link>https://mj-seok.com/posts/python-for/</link>
      <pubDate>Wed, 01 Jan 2020 17:51:58 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/python-for/</guid>
      <description>Python - for in 문법 Reference : https://youtu.be/0wpYyDlAEIg
 array, list, tuple, string 의 시퀀스를 출력  days = (&amp;#34;Mon&amp;#34;, &amp;#34;Tue&amp;#34;, &amp;#34;Wed&amp;#34;, &amp;#34;Thu&amp;#34;, &amp;#34;Fri&amp;#34;) for day in days: print(day) for day in [1, 2, 3, 4, 5]: print(day) for day in days: if day is &amp;#34;Wed&amp;#34;: break else: print(day) for letter in &amp;#34;Nicolas&amp;#34;: print(letter)   행복 코딩
 </description>
    </item>
    
    <item>
      <title>선형대수학(Linear Algebra) - 벡터(Vector) 와 튜플(Tuple)</title>
      <link>https://mj-seok.com/posts/math-linearalgebra/</link>
      <pubDate>Wed, 01 Jan 2020 17:22:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/math-linearalgebra/</guid>
      <description>선형대수학(Linear Algebra) - 벡터(Vector) 와 튜플(Tuple) [ Reference ] : https://youtu.be/br7tS1t2SFE
 프론트엔드의 다양한 애니메이션과 프로그래밍에서 다양하게 응용된다는 선형대수학! 벡터 공간, 벡터, 선형 변환, 행렬, 연립 선형 방정식등을 연구하는 대수학의 한 분야라고 합니다.  벡터 Vector  크기 magnitud 방향 direction  속도(speed) - 5mph (크기) : 스칼라(scalar)
속력(velocity) - 동쪽 (east) 5mph (크기) : 벡터(vector)
v = (5, 0) = [5] [0] 길이 : 5 v = (3, 4) = [3] [4] 길이 : 5 (피타고라스 3^2 + 4^2 = 5^2) 튜플 Tuple |R R^2 실수좌표공간 Real Coordinate Space  실수값을 가지는 모든 2-튜플 튜플 : 순서가 정해진 리스트  R^3 : 3D real Coordinate space x = [0 0 0] b = [-1 5 2] c = [i(허수) 0 1]  R^n : n - dimensional real coordinate space   </description>
    </item>
    
    <item>
      <title>재귀 설계 - Design Recursion</title>
      <link>https://mj-seok.com/posts/algo-designrecursion/</link>
      <pubDate>Wed, 01 Jan 2020 15:54:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-designrecursion/</guid>
      <description>재귀 설계 - Design Recursion [ Reference ] : https://youtu.be/Vwfo_hrxuzg
 Recursion을 어떻게 짜야할까?  순환적 알고리즘 설계  적어도 하나의 base case, 즉 순환되지 않고 종료되는 case가 있어야 함 (at least one base case) 모든 case는 결국 base case로 수렴해야 함  if () { return base_case; } else { recursion(); }  암시적(implicit) 매개변수를 명시적(explicit) 매개변수로 바꾸어라.
 순차 탐색 (Sequential Search)  배열에 내가 원하는 특정한 값이 있는지 검사 데이터들이 정렬되있다면 이진 검색 정렬되어있지 않다면(순서 조건) 하나씩 순서대로 검사  int search(int [] data, int n, int target) { for (int i=0; i&amp;lt;n; i++) if (data[i] == target) return i; return -1; }  data[0] ~ data[n-1] target을 검색하는 것 검색 구간의 시작 인덱스 0은 보통 생략합니다.</description>
    </item>
    
    <item>
      <title>Hugo로 개인 블로그 만들기 &#43; git submodule</title>
      <link>https://mj-seok.com/posts/git-submodule/</link>
      <pubDate>Mon, 30 Dec 2019 22:37:32 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/git-submodule/</guid>
      <description>Hugo로 개인 블로그 만들기 + git submodule  https://gohugo.io/
  Hugo는 &amp;ldquo;웹사이트를 만드는데 세계에서 가장 빠른 프레임워크&amp;quot;라고 단언하는
오픈소스 기반 정적 사이트(static site) 제작 툴입니다.   Hugo 설치 (Install Hugo) git Command Hugo Post  1. Hugo 설치 (Install Hugo)  https://gohugo.io/getting-started/quick-start/
 MacOS 기준 (for MacOS)
Hugo 설치 (Install Hugo) brew install hugo Hugo 버전 확인 (check Hugo&amp;rsquo;s version) hugo version Hugo 사이트 만들기 (Create a new Hugo site) hugo new site quickstart Hugo 테마 추가하기 (Add a Theme) cd quickstart git init git submodule add https://github.</description>
    </item>
    
    <item>
      <title>고로 작성해봐요 - Write in Go</title>
      <link>https://mj-seok.com/posts/go-first/</link>
      <pubDate>Mon, 30 Dec 2019 22:27:58 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/go-first/</guid>
      <description>고로 작성해봐요 - Write in Go 안녕, 고 (Hello, Go) package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, Go&amp;#34;) } Go 언어 설치 (Install Go Language) https://golang.org/
Go 설치 후 go tour 시작 코드 (After installing, go tour code) % go get code.google.com/p/go-tour/gotour 패키지 (Packages) package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) func main() { fmt.Println(&amp;#34;My favorite number is&amp;#34;, rand.Intn(10)) }  모든 Go 프로그램은 패키지로 구성 (Every Go Program is made up of packages) import () 형태로 패키지를 불러옵니다.</description>
    </item>
    
    <item>
      <title>PostgreSQL - 명령어 정리(Command)</title>
      <link>https://mj-seok.com/posts/sql-postgresql/</link>
      <pubDate>Thu, 26 Dec 2019 21:52:28 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/sql-postgresql/</guid>
      <description>PostgreSQL - 명령어 정리(Command) Install on Mac https://formulae.brew.sh/formula/postgresql
install Command brew install postgresql Server start pg_ctl -D /usr/local/var/postgres start Server stop pg_ctl -D /usr/local/var/postgres stop status check export PGDATA=&amp;#39;/usr/local/var/postgres&amp;#39; pg_ctl status  </description>
    </item>
    
    <item>
      <title>Python 가상환경 - pyenv 설치</title>
      <link>https://mj-seok.com/posts/python-pyenv/</link>
      <pubDate>Mon, 23 Dec 2019 21:24:34 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/python-pyenv/</guid>
      <description>Python 가상환경 - pyenv 설치  mac 기준, Homebrew를 사용해서 설치합니다.
 설치 % brew update % brew install pyenv 환경설정 % echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc % echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc % echo -e &amp;#39;if command -v pyenv 1&amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then\n eval &amp;#34;$(pyenv init -)&amp;#34;\nfi&amp;#39; &amp;gt;&amp;gt; ~/.zshrc Python 원하는 버전 설치 % pyenv install [version_name] % pyenv global [version_name] % python --version   행복 개발
 </description>
    </item>
    
    <item>
      <title>재귀적 생각 - Recursive Thinking</title>
      <link>https://mj-seok.com/posts/algo-recursive/</link>
      <pubDate>Sun, 22 Dec 2019 23:50:01 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/algo-recursive/</guid>
      <description>재귀적 생각 - Recursive Thinking [ Reference ] : https://youtu.be/tuzf1yLPgRI
절차적 언어 ? Procedure Language : 어떤 일을 하는 절차
프로그래밍에서의 관점  객체 지향 : 객체들 간의 상호작용 Recursion : 순환적인 관점  Recursion은 수학함수 계산에만 유용한가  수학함수뿐 아니라 다른 많은 문제들을 recursion으로 해결할 수 있습니다.  문자열의 길이 계산 :: pesudo code
if the string is empty return 0; else return 1 plus the length of the string that excludes the first character;  순환적인 문자열 길이 계산 알고리즘  :: length.</description>
    </item>
    
    <item>
      <title>DB 정규화 - Database Normalization</title>
      <link>https://mj-seok.com/posts/sql-db-normalization/</link>
      <pubDate>Thu, 19 Dec 2019 21:10:08 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/sql-db-normalization/</guid>
      <description>DB 정규화 - Database Normalization [Reference] : https://mangkyu.tistory.com/28
제1정규형 - 원자값 제2정규형 - 기본키에 완전 함수 종속 제3정규형 - 기본키가 아닌 속성이 기본키에 비이행적으로 종속(직접 종속) 제4정규형 - BCNF (함수 종속성 X-&amp;gt;Y 성립할 때 모든 결정자 X가 후보키인 정규형 이상 현상을 없애려면 함수 종속성   행복 코딩
 </description>
    </item>
    
    <item>
      <title>타입스크립트 기초 - TypeScript Basic</title>
      <link>https://mj-seok.com/posts/typescript/</link>
      <pubDate>Wed, 18 Dec 2019 21:34:00 +0900</pubDate>
      
      <guid>https://mj-seok.com/posts/typescript/</guid>
      <description>타입스크립트 기초 - TypeScript Basic [Reference] : https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html
Install npm install -g typescript  node.js가 설치되어 있는 환경에서 typescript를 npm 패키지 매니저로 전역(-g) 설치합니다.  Compile tsc helloworld.ts  컴파일 명령어는 tsc 입니다.  greeter.ts function greeter(person) { return &amp;#34;Hello, &amp;#34; + person; } let user = &amp;#34;Jane User&amp;#34;; // document.body.textContext = greeter(user); console.log(greeter(user));  가장 기본적인 방법으로 함수에 인자 넣어 콘솔에 로그를 찍습니다.  터미널 환경에서 &amp;ldquo;tsc greeter.ts&amp;rdquo;, &amp;ldquo;node greeter.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://mj-seok.com/about/</link>
      <pubDate>Wed, 18 Dec 2019 21:33:23 +0900</pubDate>
      
      <guid>https://mj-seok.com/about/</guid>
      <description>const Introduce = () =&amp;gt; { return { name: &amp;#34;Jose Seok&amp;#34;, job: &amp;#34;Front-end Developer&amp;#34;, focus: [&amp;#34;ECMAScript&amp;#34;, &amp;#34;React.js&amp;#34;, &amp;#34;Node.js&amp;#34;, &amp;#34;Algorithm&amp;#34;] }; }   행복 프로그래밍
 </description>
    </item>
    
  </channel>
</rss>